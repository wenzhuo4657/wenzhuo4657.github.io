<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>教程 on wenzhuo4657</title>
    <link>https://example.org/categories/%E6%95%99%E7%A8%8B/</link>
    <description>Recent content in 教程 on wenzhuo4657</description>
    <generator>Hugo</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sun, 25 May 2025 20:44:43 +0000</lastBuildDate>
    <atom:link href="https://example.org/categories/%E6%95%99%E7%A8%8B/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>ssh、gpg以及apt软件下载器</title>
      <link>https://example.org/posts/sshgpg%E4%BB%A5%E5%8F%8Aapt%E8%BD%AF%E4%BB%B6%E4%B8%8B%E8%BD%BD%E5%99%A8/</link>
      <pubDate>Sun, 25 May 2025 20:44:43 +0000</pubDate>
      <guid>https://example.org/posts/sshgpg%E4%BB%A5%E5%8F%8Aapt%E8%BD%AF%E4%BB%B6%E4%B8%8B%E8%BD%BD%E5%99%A8/</guid>
      <description>&lt;h1 id=&#34;小白级别的理解勿cue&#34;&gt;小白级别的理解，勿cue&lt;/h1&gt;&#xA;&lt;p&gt;首先说结论，ssh、gpt是用于加密，且在加密这个分类下属于非对称加密（指公钥加密、私钥解密），而apt是ubunt等linux系统的一个软甲下载器。&lt;/p&gt;&#xA;&lt;h2 id=&#34;sshgpg&#34;&gt;ssh、gpg&lt;/h2&gt;&#xA;&lt;h3 id=&#34;对称加密和非堆成加密&#34;&gt;对称加密和非堆成加密&lt;/h3&gt;&#xA;&lt;p&gt;对称加密算法使用相同的密钥用于加密或者解密，这使通信双方必须完全信任对方，才能够发送密钥，否则密钥就很可能被泄露，并且在传输过程中泄露也很糟糕。&lt;/p&gt;&#xA;&lt;p&gt;但是由于使用相同的密钥进行加密和解密，所以x速度比较快。&lt;/p&gt;&#xA;&lt;p&gt;而非对称加密算法将密钥分为私钥和公钥，其中私钥用于解密，公钥用于加密。所以相比于同级别的对称加密，非对称加密速度更慢，但安全性更高，我们只需要将公钥发布到任意服务器上即可实现通信（例如 keyserver）&lt;/p&gt;&#xA;&lt;h3 id=&#34;ssh和gpg的区别&#34;&gt;ssh和gpg的区别？&lt;/h3&gt;&#xA;&lt;p&gt;ssh： 常用于服务器加密（实时交互，需要处理动态数据），强度相当于钥匙。&lt;/p&gt;&#xA;&lt;p&gt;gpg： 常用于文件加密（静态数据），强度相当于保险箱。&lt;/p&gt;&#xA;&lt;h3 id=&#34;pgpgpgopenpgp&#34;&gt;pgp、gpg、OpenPGP&lt;/h3&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://www.rmnof.com/article/openpgp-gnupg-introduction/&#34;&gt;OpenPGP（PGP/GPG）深入浅出，完全入门指南&lt;/a&gt;、&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;PGP：由Phil Zimmermann开发，最终被赛门铁克收购，是一个商业软件，需要付费。&lt;/li&gt;&#xA;&lt;li&gt;OpenPGP：一种协议，定义了加密消息、签名、私钥和用于交换公钥的证书统一标准。&lt;/li&gt;&#xA;&lt;li&gt;GPG（GnuPG）：符合OpenPGP标准的开源加密软件，PGP的开源实现。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;使用&#34;&gt;使用&lt;/h2&gt;&#xA;&lt;h3 id=&#34;创建密钥&#34;&gt;创建密钥&lt;/h3&gt;&#xA;&lt;p&gt;官方推荐的工具&lt;/p&gt;&#xA;&lt;p&gt;ssh：&lt;a href=&#34;https://www.openssh.com/?spm=a2ty_o01.29997173.0.0.299fc921OTUceN&#34;&gt;OpenSSH&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;gpg： &lt;a href=&#34;https://gnupg.org/index.html&#34;&gt;GnuPG&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;公钥服务器&#34;&gt;公钥服务器&lt;/h3&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://keyserver.ubuntu.com/?spm=a2ty_o01.29997173.0.0.299fc921OTUceN#&#34;&gt;OpenPGP 密钥服务器&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://keyserver.ubuntu.com/?spm=a2ty_o01.29997173.0.0.299fc921OTUceN#&#34;&gt;OpenPGP 密钥服务器&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;使用gpg密钥&#34;&gt;使用gpg密钥&lt;/h3&gt;&#xA;&lt;p&gt;对于ssh直接进行服务器链接等操作即可，但是gpg密钥是令人迷惑的，因为他是属于静态文件的加密，这意味着灵活性低、安全性高，而这样的加密特性势必要求一个符合的场景，例如：通信的双方必须信任对方，否则没有进行交换文件的必要。&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://ulyc.github.io/2021/01/26/2021%E5%B9%B4-%E7%94%A8%E6%9B%B4%E7%8E%B0%E4%BB%A3%E7%9A%84%E6%96%B9%E6%B3%95%E4%BD%BF%E7%94%A8PGP-%E4%B8%8B/&#34;&gt;2021年，用更现代的方法使用PGP（下） - C的博客 |UlyC&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;ps： 这篇文章中说的漏洞已经被解决了，需要注意的是里面所提到的交换公钥的方式&lt;/p&gt;&#xA;&lt;h4 id=&#34;gpg的特征&#34;&gt;gpg的特征&lt;/h4&gt;&#xA;&lt;p&gt;这里的特征是指gpg密钥上的签名、指纹等名词，他们在很长一段时间一直困扰我。&lt;/p&gt;&#xA;&lt;h5 id=&#34;1--创建&#34;&gt;1，  创建&lt;/h5&gt;&#xA;&lt;p&gt;&lt;code&gt; gpg   --full-generate-key&lt;/code&gt; 该选项表示功能齐全的密钥生成&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;PS C:\Users\25370&amp;gt; gpg  --full-generate-key&#xA;gpg (GnuPG) 2.4.3; Copyright (C) 2023 g10 Code GmbH&#xA;This is free software: you are free to change and redistribute it.&#xA;There is NO WARRANTY, to the extent permitted by law.&#xA;&#xA;Please select what kind of key you want:&#xA;   (1) RSA and RSA&#xA;   (2) DSA and Elgamal&#xA;   (3) DSA (sign only)&#xA;   (4) RSA (sign only)&#xA;   (9) ECC (sign and encrypt) *default*&#xA;  (10) ECC (sign only)&#xA;  (14) Existing key from card&#xA;Your selection? 1&#xA;RSA keys may be between 1024 and 4096 bits long.&#xA;What keysize do you want? (3072) 2048&#xA;Requested keysize is 2048 bits&#xA;Please specify how long the key should be valid.&#xA;         0 = key does not expire&#xA;      &amp;lt;n&amp;gt;  = key expires in n days&#xA;      &amp;lt;n&amp;gt;w = key expires in n weeks&#xA;      &amp;lt;n&amp;gt;m = key expires in n months&#xA;      &amp;lt;n&amp;gt;y = key expires in n years&#xA;Key is valid for? (0) 1y&#xA;Key expires at 2026/5/25 21:39:55 �й���׼ʱ��&#xA;Is this correct? (y/N) y&#xA;&#xA;GnuPG needs to construct a user ID to identify your key.&#xA;&#xA;Real name: wenzhuo4657&#xA;Email address: 14783149521@163.com&#xA;Comment: test&#xA;You selected this USER-ID:&#xA;    &amp;#34;wenzhuo4657 (test) &amp;lt;14783149521@163.com&amp;gt;&amp;#34;&#xA;&#xA;Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? q&#xA;gpg: Key generation canceled.&#xA;PS C:\Users\25370&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这一部分定义了uid： wenzhuo4657 (test) &lt;a href=&#34;mailto:14783149521@163.com&#34;&gt;14783149521@163.com&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>maven插件新手解惑</title>
      <link>https://example.org/posts/maven%E6%8F%92%E4%BB%B6%E6%96%B0%E6%89%8B%E8%A7%A3%E6%83%91/</link>
      <pubDate>Sun, 06 Apr 2025 16:44:01 +0000</pubDate>
      <guid>https://example.org/posts/maven%E6%8F%92%E4%BB%B6%E6%96%B0%E6%89%8B%E8%A7%A3%E6%83%91/</guid>
      <description>&lt;h2 id=&#34;maven插件的定义&#34;&gt;maven插件的定义&lt;/h2&gt;&#xA;&lt;p&gt;maven插件的定义是在pom文件下的&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;plugins&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;plugin&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &#x9;&#x9;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;groupId&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;org.&lt;span style=&#34;color:#a6e22e&#34;&gt;springframework&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;boot&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/&lt;/span&gt;groupId&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;artifactId&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;spring&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;boot&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;maven&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;plugin&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/&lt;/span&gt;artifactId&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;version&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;2.&lt;span style=&#34;color:#a6e22e&#34;&gt;6&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/&lt;/span&gt;version&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;   &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/&lt;/span&gt;plugin&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/&lt;/span&gt;plugins&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;与常规的依赖定位一致，而插件的配置则是在&lt;!-- raw HTML omitted --&gt;、&lt;!-- raw HTML omitted --&gt;等标签下定义的，他们或许是环境变量或许是在maven生命周期的插入点。&lt;/p&gt;&#xA;&lt;p&gt;简单来说maven插件的两个用途&lt;/p&gt;&#xA;&lt;p&gt;1,融入maven生命周期，增加外挂式的功能&lt;/p&gt;&#xA;&lt;p&gt;2,不参入maven生周期，直接使用（例如，在微服务领域下，将服务的定义IDL文件编译为特定语言的接口文件。）&lt;/p&gt;&#xA;&lt;h2 id=&#34;maven插件的原理&#34;&gt;maven插件的原理&lt;/h2&gt;&#xA;&lt;p&gt;&lt;strong&gt;Maven 是一个意第绪语单词，意为 知识的积累者，最初是为了简化 Jakarta Turbine 项目的构建过程而创建的。当时有多个项目，每个项目都有自己的 Ant 构建文件，而且每个文件都略有不同。JAR 被签入 CVS。我们希望有一种标准的方法来构建项目，明确定义项目包含的内容，一种发布项目信息的简便方法，以及一种在多个项目之间共享 JAR 的方法。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;这段话取自&lt;a href=&#34;https://maven.apache.org/what-is-maven.html&#34;&gt;官网&lt;/a&gt;对于maven的定义,可以看出maven的核心在于管理jar文件，便于多个不同的项目去引入相同的jar。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;“Maven” 实际上只是一组 Maven 插件的核心框架。换句话说，插件是执行大部分实际操作的地方，插件用于：创建 jar 文件、创建 war 文件、编译代码、单元测试代码、创建项目文档等等。您能想到的在项目上执行的几乎所有操作都是作为 Maven 插件实现的。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;这段话取自&lt;a href=&#34;https://maven.apache.org/guides/introduction/introduction-to-plugins.html&#34;&gt;插件开发简介&lt;/a&gt;,也就是说maven的插件的目标是生命周期，而生命周期在官方术语中被称为&lt;code&gt;Mojo&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;p&gt;进而去查看maven插件开发的示例即可发现，插件实际上就是依托与maven这个框架所提供的扩展点所构建出来的可执行jar文件。&lt;/p&gt;&#xA;&lt;p&gt;至此对于maven插件的和依赖的之间的关系就已经很明确了，他们实际上是一样，都可以作为依赖去使用，实际上更准确的说法是，可以融入maven生命周期的依赖被称为maven插件。&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;如果想要学习maven插件开发，就一定要仔细查看maven的&lt;a href=&#34;https://maven.apache.org/plugin-developers/index.html&#34;&gt;官方文档&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;maven插件示例解读&#34;&gt;maven插件示例解读&lt;/h2&gt;&#xA;&lt;h3 id=&#34;spring-boot-maven-plugin&#34;&gt;spring-boot-maven-plugin&lt;/h3&gt;&#xA;&lt;h4 id=&#34;前置知识&#34;&gt;前置知识&lt;/h4&gt;&#xA;&lt;p&gt;什么是springboot?通常我们说springboot是对于各种依赖自动配置的boot工具，便于快速开发，避免依赖的困扰，这种方式目前已经不止是springboot的独有，只是它依托与spring生态最为出名而已。&lt;/p&gt;&#xA;&lt;p&gt;springboot与spring最大的区别在我这个小白看来则是注解开发，@SpringBootApplication定义程序的启动入口，所有的程序都需要依托于这个主类进行加载，而传统的spring项目则需要依托与web容器启动servlet配置，也就WebApplicationInitializer（简单来说是用于将项目中所有的servlet加载到web容器当中，参如http请求当中的rest控制器部分）。&lt;/p&gt;&#xA;&lt;p&gt;无论如何我们需要明白一个jar包的执行是需要一个入口！而不同项目的入口是不一样！&lt;/p&gt;&#xA;&lt;p&gt;对于普通jar包来说，他只需要将当前项目的class文件打包即可，而一个可执行的jar包则额外的需要依赖、入口、引导器。（如果稍微了解一点jvm知识就应该明白，java程序并不会在加载阶段去校验import是否存在，至于执行更是需要一个明确的入口。）&lt;/p&gt;&#xA;&lt;p&gt;可执行jar:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;将依赖引入jar包当中&lt;/li&gt;&#xA;&lt;li&gt;META-INF/MANIFEST.MF文件中存在启动类等配置&lt;/li&gt;&#xA;&lt;li&gt;使用命令&lt;code&gt;java -jar&lt;/code&gt; 执行&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;不可执行jar:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;内部只有项目的class文件&lt;/li&gt;&#xA;&lt;li&gt;META-INF/MANIFEST.MF文件中不存在启动类等配置&lt;/li&gt;&#xA;&lt;li&gt;不能使用&lt;code&gt;java -jar&lt;/code&gt; 执行。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;java -jar执行逻辑： JVM会根据MANIFEST.MF文件中的Main-Class属性找到程序的入口点（即主类），然后开始执行该类的main方法&lt;/p&gt;</description>
    </item>
    <item>
      <title>git入门系列（一）</title>
      <link>https://example.org/posts/git%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97%E4%B8%80/</link>
      <pubDate>Wed, 12 Mar 2025 15:37:15 +0000</pubDate>
      <guid>https://example.org/posts/git%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97%E4%B8%80/</guid>
      <description>&lt;h1 id=&#34;git是什么&#34;&gt;git是什么？&lt;/h1&gt;&#xA;&lt;h2 id=&#34;以键值数据库为基础的文件版本控制系统&#34;&gt;以键值数据库为基础的文件版本控制系统&lt;/h2&gt;&#xA;&lt;p&gt;参考：https://git-scm.com/book/zh/v2/%e8%b5%b7%e6%ad%a5-Git-%e6%98%af%e4%bb%80%e4%b9%88%ef%bc%9f&lt;/p&gt;&#xA;&lt;p&gt;提醒： 本篇大部分在git官网都存在，只是顺序不一致，按我理解，这样有助于直接理解git的钩子机制。&lt;/p&gt;&#xA;&lt;p&gt;传统的文件版本数据库通过累计文件差异来区分文件版本，而git则是通过不断累计文件快照，然后使用链接管理当前版本应该显示的文件！&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;好处：如果存储文件差异，则不可避免的需要从文件内部开始操作，所带来的是复杂且绝不能出错的高安全性要求，而git管理文件链接，换言之，他只需要保存每个版本的文件链接列表即可，对于真实的文件数据，他们互相隔离。&lt;/li&gt;&#xA;&lt;li&gt;坏处：文件系统容易变得臃肿庞大。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;参考:https://git-scm.com/book/zh/v2/Git-%e5%86%85%e9%83%a8%e5%8e%9f%e7%90%86-Git-%e5%af%b9%e8%b1%a1&lt;/p&gt;&#xA;&lt;p&gt;文件快照存储的方式则是键值数据库，位于.git/objects 目录。&lt;/p&gt;&#xA;&lt;p&gt;存储值，并返回唯一键（SHA-1 哈希值）：&lt;code&gt;echo &#39;test content&#39; | git hash-object -w --stdin&lt;/code&gt;&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ echo &amp;#39;test content&amp;#39; | git hash-object -w --stdin&#xA;d670460b4b4aece5915caf5c68d12f560a9fe3e4&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;取出：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4&#xA;test content&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此外还有树对象用于组织这些键值。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://blog.wenzhuo4657.org/img/image-20250312155433934.png&#34; alt=&#34;image-20250312155433934&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;但是这仍然不是我们所熟知的git commit提交对象，这并没有提交信息的对应，这一点简单的说即是sha-1哈希值和文本的对应。随意找一个仓库都可以看到他们之间的关联。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://blog.wenzhuo4657.org/img/image-20250312155805995.png&#34; alt=&#34;image-20250312155805995&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;待补充&#34;&gt;待补充&lt;/h2&gt;&#xA;&lt;h1 id=&#34;钩子函数&#34;&gt;钩子函数&lt;/h1&gt;&#xA;&lt;p&gt;git的钩子位于&lt;code&gt;.git\hooks&lt;/code&gt;,默认情况下都是.sample结尾，去掉这个后缀即可启用。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://blog.wenzhuo4657.org/img/image-20250312160203955.png&#34; alt=&#34;image-20250312160203955&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;尝试打开即可他先，他们都是统一的shell脚本，所以如果想要看懂是需要一点基础的。&lt;/p&gt;&#xA;&lt;p&gt;统一机制：当以非零退出脚本时，停止提交。&lt;/p&gt;&#xA;&lt;p&gt;提醒：shell脚本的运行并不是git管理的一部分，他们只是使用了git命令的一段编码，通常使用/bin/bash解释器运行。&lt;/p&gt;&#xA;&lt;h2 id=&#34;pre-commit提交前执行&#34;&gt;pre-commit：提交前执行&lt;/h2&gt;&#xA;&lt;p&gt;作用：当前分支是否存在，如果不存在会提供一个sha-1哈希值。&lt;/p&gt;&#xA;&lt;p&gt;git rev-parse &amp;ndash;verify HEAD  （该命令可以验证参数是否可以转换为sha-1哈希值，即他是否在对象数据库中有对应关系，常见有分支名、标签名）&lt;/p&gt;&#xA;&lt;h2 id=&#34;prepare-commit-msg提交前执行&#34;&gt;prepare-commit-msg：提交前执行&lt;/h2&gt;&#xA;&lt;p&gt;作用：&lt;/p&gt;&#xA;&lt;p&gt;1，修改默认提交消息&lt;/p&gt;&#xA;&lt;p&gt;2，添加gpt签名&lt;/p&gt;&#xA;&lt;p&gt;3，将 git diff 结果插入提交消息的注释部分（咱不理解，自行查询）&lt;/p&gt;&#xA;&lt;p&gt;修改默认消息最直接的途径就是在文件末尾&lt;code&gt;echo &amp;quot;default msg&amp;quot; &amp;gt; $1&lt;/code&gt;,这样就会覆盖&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;/usr/bin/perl -i.bak -ne &#39;print unless(m/^. Please enter the commit message/..m/^#$/)&#39; &amp;quot;$COMMIT_MSG_FILE&amp;quot;&lt;/code&gt;&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
