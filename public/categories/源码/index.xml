<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>源码 on 猢狲</title>
    <link>http://localhost:1313/categories/%E6%BA%90%E7%A0%81/</link>
    <description>Recent content in 源码 on 猢狲</description>
    <generator>Hugo</generator>
    <language>zh-CN</language>
    <lastBuildDate>Wed, 16 Apr 2025 19:28:54 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/categories/%E6%BA%90%E7%A0%81/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>rocketmq源码阅读（一）：生产者初识</title>
      <link>http://localhost:1313/posts/rocketmq%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%80%E7%94%9F%E4%BA%A7%E8%80%85%E5%88%9D%E8%AF%86/</link>
      <pubDate>Wed, 16 Apr 2025 19:28:54 +0000</pubDate>
      <guid>http://localhost:1313/posts/rocketmq%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%80%E7%94%9F%E4%BA%A7%E8%80%85%E5%88%9D%E8%AF%86/</guid>
      <description>&lt;h1 id=&#34;源码阅读一&#34;&gt;源码阅读（一）&lt;/h1&gt;&#xA;&lt;h2 id=&#34;搭建环境&#34;&gt;搭建环境&lt;/h2&gt;&#xA;&lt;p&gt;rocketmq的java-sdk并没有什么特殊的构建的，直接加载maven即可。&lt;/p&gt;&#xA;&lt;p&gt;节点部署：&#xA;&lt;a href=&#34;https://rocketmq.apache.org/zh/docs/quickStart/02quickstartWithDocker&#34;&gt;Docker 部署 RocketMQ | RocketMQ&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;面板部署：&#xA;&lt;a href=&#34;https://github.com/apache/rocketmq-dashboard&#34;&gt;apache/rocketmq-dashboard&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;hhh，遵从官网部署，点点点就可以了。&lt;/p&gt;&#xA;&lt;h2 id=&#34;生产者初识&#34;&gt;生产者初识&lt;/h2&gt;&#xA;&lt;p&gt;阅读源码首先要明确的目标，或者说我们想要了解什么？&lt;/p&gt;&#xA;&lt;p&gt;在我看来生产者的职责分为以下几个&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;1,与&lt;code&gt;namesrv&lt;/code&gt;沟通，维护本地的&lt;code&gt;broker&lt;/code&gt;通信队列&lt;/li&gt;&#xA;&lt;li&gt;2,发送&lt;code&gt;topic&lt;/code&gt;消息到远程&lt;code&gt;broker&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;3,根据响应结果判断是否发送成功，以及失败情况下的策略&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;每一个生产者对于&lt;code&gt;broker&lt;/code&gt;节点来说是消息的来源，但是&lt;code&gt;broker&lt;/code&gt;并不关心究竟有多少个生产者在为它提供服务，对于消费者来说同样如此！&lt;/p&gt;&#xA;&lt;p&gt;首先定位到源码示例&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;%5Bhttps://blog.wenzhuo4657.org/img/2025/04/ce5a9ce6d095400e1dfefe77486c2729.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;示例的逻辑并不复杂，但问题是怎么处理的？尝试追溯&lt;code&gt;DefaultMQProducer&lt;/code&gt;,找到客户端的sdk模块&lt;code&gt;rocketmq-client&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;观察&lt;code&gt;DefaultMQProducer&lt;/code&gt;的父类路径发现&lt;code&gt;extends ClientConfig implements MQProducer&lt;/code&gt;,对于&lt;code&gt;MQProducer&lt;/code&gt;没啥好说的，定义了生产者方法规范，而且没有注释。小白一只的我将目光对准&lt;code&gt;ClientConfig&lt;/code&gt;,&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;private String clientIP = NetworkUtil.getLocalAddress();&lt;/code&gt;  寻找ip的方法。&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;private String instanceName = System.getProperty(&amp;quot;rocketmq.client.name&amp;quot;, &amp;quot;DEFAULT&amp;quot;);&lt;/code&gt;  生产者名称&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    # 客户端id，这个要注意与生产者名称区分，在我看来是类似与多元组一样的， ip+instanceName+......&#xA;   &#xA;    public String buildMQClientId() {&#xA;        StringBuilder sb = new StringBuilder();&#xA;        sb.append(this.getClientIP());&#xA;&#xA;        sb.append(&amp;#34;@&amp;#34;);&#xA;        sb.append(this.getInstanceName());&#xA;        if (!UtilAll.isBlank(this.unitName)) {&#xA;            sb.append(&amp;#34;@&amp;#34;);&#xA;            sb.append(this.unitName);&#xA;        }&#xA;&#xA;        if (enableStreamRequestType) {&#xA;            sb.append(&amp;#34;@&amp;#34;);&#xA;            sb.append(RequestType.STREAM);&#xA;        }&#xA;&#xA;        return sb.toString();&#xA;    }&#xA;    &#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;需要注意的是对于修改&lt;code&gt;clentIP&lt;/code&gt;可以直接通过&lt;code&gt;producer.setClientIP(DEFAULT_NAMESRVADDR);&lt;/code&gt;,&lt;code&gt;clientID&lt;/code&gt;则并没有这个字段，他是在生产者启动时自动生成的的一个标识符，或许可以这么说 &lt;code&gt;ip+instanceName&lt;/code&gt;表示了这个主机上的所有rocketmq的消费者和生产者。&lt;/p&gt;&#xA;&lt;p&gt;追溯&lt;code&gt;buildMQClientId&lt;/code&gt;即可发现，start的调用链路中存在这个方法。&lt;/p&gt;</description>
    </item>
    <item>
      <title>tomcat源码阅读（二）</title>
      <link>http://localhost:1313/posts/tomcat%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%BA%8C/</link>
      <pubDate>Mon, 10 Mar 2025 14:59:35 +0000</pubDate>
      <guid>http://localhost:1313/posts/tomcat%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%BA%8C/</guid>
      <description>&lt;h1 id=&#34;tomcat源码阅读&#34;&gt;tomcat源码阅读&lt;/h1&gt;&#xA;&lt;h2 id=&#34;日志模块梳理&#34;&gt;日志模块梳理&lt;/h2&gt;&#xA;&lt;p&gt;现在日志通常分为日志门面和日志的具体实现。&lt;/p&gt;&#xA;&lt;p&gt;日志门面：充当应用程序和日志框架之间的沟通媒介，可以在程序无感的条件下更换日志框架。&lt;/p&gt;&#xA;&lt;p&gt;日志的具体实现：直接记录日志(console、file)，并且需要注意的是，这些信息都是由日志门面交给日志实现的。&lt;/p&gt;&#xA;&lt;p&gt;对于非日志编程的程序员来说，我们只需要明白如何根据日志门面切换日志实现即可，没必要阅读日志实现的代码。&lt;/p&gt;&#xA;&lt;p&gt;常见的日志门面：JCL、slf4j&lt;/p&gt;&#xA;&lt;p&gt;常见的日志实现：JUL（java.util.logging）、log4j、logback、log4j2&lt;/p&gt;&#xA;&lt;h3 id=&#34;tomcat的日志门面juli&#34;&gt;tomcat的日志门面JULI&lt;/h3&gt;&#xA;&lt;p&gt;该日志门面位于源码包&lt;code&gt;org.apache.juli&lt;/code&gt;,基于JCL实现的。&lt;/p&gt;&#xA;&lt;p&gt;较为重要的三个类：&lt;/p&gt;&#xA;&lt;p&gt;org.apache.juli.logging.Log： 日志接口&lt;/p&gt;&#xA;&lt;p&gt;org.apache.juli.logging.DirectJDKLog：tomcat的默认日志实现。&lt;/p&gt;&#xA;&lt;p&gt;org.apache.juli.logging.LogFactory: 与tomcat进行交互获取log接口实现。&lt;/p&gt;&#xA;&lt;p&gt;在源码中可以看到，无论是什么类要记录日志都必须使用到Log的实现类，而对于tomcat源码来说，唯一获取该实例的途径就是LogFactory#getLog(Class&lt;!-- raw HTML omitted --&gt; clazz)。&lt;/p&gt;&#xA;&lt;p&gt;并且在LogFactory#release(ClassLoader classLoader)也可以看到日志实现默认为JUL,硬编码控制的。&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    public static void release(ClassLoader classLoader) {&#xA;        // JULI&amp;#39;s log manager looks at the current classLoader so there is no&#xA;        // need to use the passed in classLoader, the default implementation&#xA;        // does not so calling reset in that case will break things&#xA;        if (!LogManager.getLogManager().getClass().getName().equals(&#xA;                &amp;#34;java.util.logging.LogManager&amp;#34;)) {&#xA;            LogManager.getLogManager().reset();&#xA;        }&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;关于日志实现log的加载&#34;&gt;关于日志实现log的加载&lt;/h2&gt;&#xA;&lt;p&gt;在LogFactory的无参构造器器中看到关键语句&lt;/p&gt;</description>
    </item>
    <item>
      <title>tomcat源码阅读（一）</title>
      <link>http://localhost:1313/posts/tomcat%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%80/</link>
      <pubDate>Fri, 07 Mar 2025 16:07:46 +0000</pubDate>
      <guid>http://localhost:1313/posts/tomcat%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%80/</guid>
      <description>&lt;h1 id=&#34;tomcat源码&#34;&gt;tomcat源码&lt;/h1&gt;&#xA;&lt;h2 id=&#34;idea环境搭建&#34;&gt;idea环境搭建&lt;/h2&gt;&#xA;&lt;p&gt;源码版本apache-tomcat-9.0.43-src&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://archive.apache.org/dist/tomcat/tomcat-9/v9.0.43/src/&#34;&gt;https://archive.apache.org/dist/tomcat/tomcat-9/v9.0.43/src/&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;注意： 不同版本的搭建方式可能略有不同，但这源码核心是大差不差的。&lt;/p&gt;&#xA;&lt;h3 id=&#34;安装ant已安装的可以直接跳过&#34;&gt;安装ant(已安装的可以直接跳过)&lt;/h3&gt;&#xA;&lt;p&gt;Apache Ant 是一个帮助构建软件的 Java 库和命令行工具。&lt;/p&gt;&#xA;&lt;p&gt;官网：https://ant.apache.org/bindownload.cgi&lt;/p&gt;&#xA;&lt;p&gt;直接下载最新版即可，解压之后设置环境变量&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ANT_HOME=/Library/Apache/apache-ant-1.9.15&#xA;PATH=$PATH:$ANT_HOME/bin&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用&lt;code&gt;ant -verison&lt;/code&gt;验证安装是否成功&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://blog.wenzhuo4657.org/img/image-20250307171403529.png&#34; alt=&#34;image-20250307171403529&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;构建项目&#34;&gt;构建项目&lt;/h3&gt;&#xA;&lt;p&gt;&lt;em&gt;在打开idea之前操作，这一点非常重要！！！否则会由于编译器的一些操作导致XXXXX&lt;/em&gt;&lt;/p&gt;&#xA;&lt;p&gt;直接将res目录idea-support中的.idea文件粘贴到根目录中的.idea（手动创建&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://blog.wenzhuo4657.org/img/image-20250309134412453.png&#34; alt=&#34;image-20250309134412453&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://blog.wenzhuo4657.org/img/image-20250309134454556.png&#34; alt=&#34;image-20250309134454556&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://blog.wenzhuo4657.org/img/image-20250309134544101.png&#34; alt=&#34;image-20250309134544101&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;此时打开项目可以发现项目被正确加载，但是会依赖报错&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://blog.wenzhuo4657.org/img/image-20250309135659189.png&#34; alt=&#34;image-20250309135659189&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;尝试构建项目，启动test&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://blog.wenzhuo4657.org/img/image-20250309135743059.png&#34; alt=&#34;image-20250309135743059&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://blog.wenzhuo4657.org/img/image-20250309134654470.png&#34; alt=&#34;image-20250309134654470&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;将这些jar包和ant目录下的lib库加入项目的外部库即可。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://blog.wenzhuo4657.org/img/image-20250309141125493.png&#34; alt=&#34;image-20250309141125493&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;启动&#34;&gt;启动&lt;/h2&gt;&#xA;&lt;p&gt;找到启动类Bootstrap&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://blog.wenzhuo4657.org/img/image-20250309141245515.png&#34; alt=&#34;image-20250309141245515&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://blog.wenzhuo4657.org/img/image-20250309141253099.png&#34; alt=&#34;image-20250309141253099&#34;&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;中文乱码&#34;&gt;中文乱码&lt;/h1&gt;&#xA;&lt;p&gt;对于乱码，网上搜索在日志配置中更改编码，&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/weixin_44109450/article/details/126544310&#34;&gt;https://blog.csdn.net/weixin_44109450/article/details/126544310&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;但是对于源码编译环境来说，似乎并不会读取conf下的配置，追溯源码找到&lt;code&gt;java.util.logging.ConsoleHandler&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;p&gt;断点调试发现，并没有获取到配置&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://blog.wenzhuo4657.org/img/image-20250309142742777.png&#34; alt=&#34;image-20250309142742777&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;并且由于该类属于依赖包jdk的一部分，&lt;img src=&#34;https://blog.wenzhuo4657.org/img/image-20250309142835530.png&#34; alt=&#34;image-20250309142835530&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;进一步追溯之后发现关键读取文件的方法LogManager#readConfiguration（）&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;   String fname = System.getProperty(&amp;#34;java.util.logging.config.file&amp;#34;);&#xA;        if (fname == null) {&#xA;            fname = System.getProperty(&amp;#34;java.home&amp;#34;);&#xA;            if (fname == null) {&#xA;                throw new Error(&amp;#34;Can&amp;#39;t find java.home ??&amp;#34;);&#xA;            }&#xA;            File f = new File(fname, &amp;#34;lib&amp;#34;);&#xA;            f = new File(f, &amp;#34;logging.properties&amp;#34;);&#xA;            fname = f.getCanonicalPath();&#xA;        }&#xA;        try (final InputStream in = new FileInputStream(fname)) {&#xA;            final BufferedInputStream bin = new BufferedInputStream(in);&#xA;            readConfiguration(bin);&#xA;        }&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;首先说结论，无论使更改成conf还是jdk目录下的logging.properties,他们所影响的编码都只是外层的一部分，不能影响tomcat输出的报错信息。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
