<!DOCTYPE html>
<html lang="zh-CN">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>猢狲</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="">
    <meta name="generator" content="Hugo 0.147.8">
    
    
    
      <meta name="robots" content="noindex, nofollow">
    
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >




    


    
      

    

    
    
      <link href="/categories/index.xml" rel="alternate" type="application/rss+xml" title="猢狲" />
      <link href="/categories/index.xml" rel="feed" type="application/rss+xml" title="猢狲" />
      
    

    
      <link rel="canonical" href="http://localhost:1313/categories/">
    

    <meta property="og:url" content="http://localhost:1313/categories/">
  <meta property="og:site_name" content="猢狲">
  <meta property="og:title" content="Categories">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

  <meta itemprop="name" content="Categories">
  <meta itemprop="datePublished" content="2025-05-25T20:44:43+00:00">
  <meta itemprop="dateModified" content="2025-05-25T20:44:43+00:00">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Categories">

	
  </head><body class="ma0 avenir bg-near-white development">

    

  <header>
    <div class="pb3-m pb6-l bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l center items-center justify-between">
    <a href="/" class="f3 fw2 hover-white white-90 dib no-underline">
      
        猢狲
      
    </a>
    <div class="flex-l items-center">
      

      
        <ul class="pl0 mr3">
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white white-90 no-underline" href="/" title="主页 page">
              主页
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white white-90 no-underline" href="/posts/" title="文章 page">
              文章
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white white-90 no-underline" href="/about/" title="about page">
              about
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white white-90 no-underline" href="/posts/" title=" page">
              
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white white-90 no-underline" href="/posts/" title=" page">
              
            </a>
          </li>
          
        </ul>
      
      <div class="ananke-socials"></div>

    </div>
  </div>
</nav>

      <div class="tc-l pv3 ph3 ph4-ns">
        <h1 class="f2 f-subheadline-l fw2 light-silver mb0 lh-title">
          Categories
        </h1>
        
      </div>
    </div>
  </header>


    <main class="pb7" role="main">
      
    
  <article class="cf pa3 pa4-m pa4-l">
    <div class="measure-wide-l center f4 lh-copy nested-copy-line-height nested-links mid-gray">
      
    </div>
  </article>
  <div class="mw8 center">
    <section class="ph4">
      
        <h2 class="f1">
          <a href="/categories/%E6%95%99%E7%A8%8B/" class="link blue hover-black">
            Category: 教程
          </a>
        </h2>
        
            <div class="mb3 pa4 mid-gray overflow-hidden">
    
      <div class="f6">
        May 25, 2025
      </div>
    
    <h1 class="f3 near-black">
      <a href="/posts/sshgpg%E4%BB%A5%E5%8F%8Aapt%E8%BD%AF%E4%BB%B6%E4%B8%8B%E8%BD%BD%E5%99%A8/" class="link black dim">
        ssh、gpg以及apt软件下载器   
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      <h1 id="小白级别的理解勿cue">小白级别的理解，勿cue</h1>
<p>首先说结论，ssh、gpt是用于加密，且在加密这个分类下属于非对称加密（指公钥加密、私钥解密），而apt是ubunt等linux系统的一个软甲下载器。</p>
<h2 id="sshgpg">ssh、gpg</h2>
<h3 id="对称加密和非堆成加密">对称加密和非堆成加密</h3>
<p>对称加密算法使用相同的密钥用于加密或者解密，这使通信双方必须完全信任对方，才能够发送密钥，否则密钥就很可能被泄露，并且在传输过程中泄露也很糟糕。</p>
<p>但是由于使用相同的密钥进行加密和解密，所以x速度比较快。</p>
<p>而非对称加密算法将密钥分为私钥和公钥，其中私钥用于解密，公钥用于加密。所以相比于同级别的对称加密，非对称加密速度更慢，但安全性更高，我们只需要将公钥发布到任意服务器上即可实现通信（例如 keyserver）</p>
<h3 id="ssh和gpg的区别">ssh和gpg的区别？</h3>
<p>ssh： 常用于服务器加密（实时交互，需要处理动态数据），强度相当于钥匙。</p>
<p>gpg： 常用于文件加密（静态数据），强度相当于保险箱。</p>
<h3 id="pgpgpgopenpgp">pgp、gpg、OpenPGP</h3>
<p><a href="https://www.rmnof.com/article/openpgp-gnupg-introduction/">OpenPGP（PGP/GPG）深入浅出，完全入门指南</a>、</p>
<ul>
<li>PGP：由Phil Zimmermann开发，最终被赛门铁克收购，是一个商业软件，需要付费。</li>
<li>OpenPGP：一种协议，定义了加密消息、签名、私钥和用于交换公钥的证书统一标准。</li>
<li>GPG（GnuPG）：符合OpenPGP标准的开源加密软件，PGP的开源实现。</li>
</ul>
<h2 id="使用">使用</h2>
<h3 id="创建密钥">创建密钥</h3>
<p>官方推荐的工具</p>
<p>ssh：<a href="https://www.openssh.com/?spm=a2ty_o01.29997173.0.0.299fc921OTUceN">OpenSSH</a></p>
<p>gpg： <a href="https://gnupg.org/index.html">GnuPG</a></p>
<h3 id="公钥服务器">公钥服务器</h3>
<p><a href="https://keyserver.ubuntu.com/?spm=a2ty_o01.29997173.0.0.299fc921OTUceN#">OpenPGP 密钥服务器</a></p>
<p><a href="https://keyserver.ubuntu.com/?spm=a2ty_o01.29997173.0.0.299fc921OTUceN#">OpenPGP 密钥服务器</a></p>
<h3 id="使用gpg密钥">使用gpg密钥</h3>
<p>对于ssh直接进行服务器链接等操作即可，但是gpg密钥是令人迷惑的，因为他是属于静态文件的加密，这意味着灵活性低、安全性高，而这样的加密特性势必要求一个符合的场景，例如：通信的双方必须信任对方，否则没有进行交换文件的必要。</p>
<p><a href="https://ulyc.github.io/2021/01/26/2021%E5%B9%B4-%E7%94%A8%E6%9B%B4%E7%8E%B0%E4%BB%A3%E7%9A%84%E6%96%B9%E6%B3%95%E4%BD%BF%E7%94%A8PGP-%E4%B8%8B/">2021年，用更现代的方法使用PGP（下） - C的博客 |UlyC</a></p>
<p>ps： 这篇文章中说的漏洞已经被解决了，需要注意的是里面所提到的交换公钥的方式</p>
<h4 id="gpg的特征">gpg的特征</h4>
<p>这里的特征是指gpg密钥上的签名、指纹等名词，他们在很长一段时间一直困扰我。</p>
<h5 id="1--创建">1，  创建</h5>
<p><code> gpg   --full-generate-key</code> 该选项表示功能齐全的密钥生成</p>
<pre tabindex="0"><code>PS C:\Users\25370&gt; gpg  --full-generate-key
gpg (GnuPG) 2.4.3; Copyright (C) 2023 g10 Code GmbH
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

Please select what kind of key you want:
   (1) RSA and RSA
   (2) DSA and Elgamal
   (3) DSA (sign only)
   (4) RSA (sign only)
   (9) ECC (sign and encrypt) *default*
  (10) ECC (sign only)
  (14) Existing key from card
Your selection? 1
RSA keys may be between 1024 and 4096 bits long.
What keysize do you want? (3072) 2048
Requested keysize is 2048 bits
Please specify how long the key should be valid.
         0 = key does not expire
      &lt;n&gt;  = key expires in n days
      &lt;n&gt;w = key expires in n weeks
      &lt;n&gt;m = key expires in n months
      &lt;n&gt;y = key expires in n years
Key is valid for? (0) 1y
Key expires at 2026/5/25 21:39:55 �й���׼ʱ��
Is this correct? (y/N) y

GnuPG needs to construct a user ID to identify your key.

Real name: wenzhuo4657
Email address: 14783149521@163.com
Comment: test
You selected this USER-ID:
    &#34;wenzhuo4657 (test) &lt;14783149521@163.com&gt;&#34;

Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? q
gpg: Key generation canceled.
PS C:\Users\25370&gt;
</code></pre><p>这一部分定义了uid： wenzhuo4657 (test) <a href="mailto:14783149521@163.com">14783149521@163.com</a></p>
    </div>
  <a href="/posts/sshgpg%E4%BB%A5%E5%8F%8Aapt%E8%BD%AF%E4%BB%B6%E4%B8%8B%E8%BD%BD%E5%99%A8/" class="ba b--moon-gray bg-light-gray br2 color-inherit dib f7 hover-bg-moon-gray link mt2 ph2 pv1">read more</a>
  </div>

        
            <div class="mb3 pa4 mid-gray overflow-hidden">
    
      <div class="f6">
        April 6, 2025
      </div>
    
    <h1 class="f3 near-black">
      <a href="/posts/maven%E6%8F%92%E4%BB%B6%E6%96%B0%E6%89%8B%E8%A7%A3%E6%83%91/" class="link black dim">
        maven插件新手解惑   
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      <h2 id="maven插件的定义">maven插件的定义</h2>
<p>maven插件的定义是在pom文件下的</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">&lt;</span>plugins<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;</span>plugin<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    		<span style="color:#f92672">&lt;</span>groupId<span style="color:#f92672">&gt;</span>org.<span style="color:#a6e22e">springframework</span>.<span style="color:#a6e22e">boot</span><span style="color:#f92672">&lt;/</span>groupId<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">&lt;</span>artifactId<span style="color:#f92672">&gt;</span>spring<span style="color:#f92672">-</span>boot<span style="color:#f92672">-</span>maven<span style="color:#f92672">-</span>plugin<span style="color:#f92672">&lt;/</span>artifactId<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">&lt;</span>version<span style="color:#f92672">&gt;</span>2.<span style="color:#a6e22e">6</span>.<span style="color:#a6e22e">0</span><span style="color:#f92672">&lt;/</span>version<span style="color:#f92672">&gt;</span>   
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">&lt;/</span>plugin<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span> <span style="color:#f92672">&lt;/</span>plugins<span style="color:#f92672">&gt;</span>
</span></span></code></pre></div><p>与常规的依赖定位一致，而插件的配置则是在<!-- raw HTML omitted -->、<!-- raw HTML omitted -->等标签下定义的，他们或许是环境变量或许是在maven生命周期的插入点。</p>
<p>简单来说maven插件的两个用途</p>
<p>1,融入maven生命周期，增加外挂式的功能</p>
<p>2,不参入maven生周期，直接使用（例如，在微服务领域下，将服务的定义IDL文件编译为特定语言的接口文件。）</p>
<h2 id="maven插件的原理">maven插件的原理</h2>
<p><strong>Maven 是一个意第绪语单词，意为 知识的积累者，最初是为了简化 Jakarta Turbine 项目的构建过程而创建的。当时有多个项目，每个项目都有自己的 Ant 构建文件，而且每个文件都略有不同。JAR 被签入 CVS。我们希望有一种标准的方法来构建项目，明确定义项目包含的内容，一种发布项目信息的简便方法，以及一种在多个项目之间共享 JAR 的方法。</strong></p>
<p>这段话取自<a href="https://maven.apache.org/what-is-maven.html">官网</a>对于maven的定义,可以看出maven的核心在于管理jar文件，便于多个不同的项目去引入相同的jar。</p>
<p><strong>“Maven” 实际上只是一组 Maven 插件的核心框架。换句话说，插件是执行大部分实际操作的地方，插件用于：创建 jar 文件、创建 war 文件、编译代码、单元测试代码、创建项目文档等等。您能想到的在项目上执行的几乎所有操作都是作为 Maven 插件实现的。</strong></p>
<p>这段话取自<a href="https://maven.apache.org/guides/introduction/introduction-to-plugins.html">插件开发简介</a>,也就是说maven的插件的目标是生命周期，而生命周期在官方术语中被称为<code>Mojo</code>.</p>
<p>进而去查看maven插件开发的示例即可发现，插件实际上就是依托与maven这个框架所提供的扩展点所构建出来的可执行jar文件。</p>
<p>至此对于maven插件的和依赖的之间的关系就已经很明确了，他们实际上是一样，都可以作为依赖去使用，实际上更准确的说法是，可以融入maven生命周期的依赖被称为maven插件。</p>
<p><em>如果想要学习maven插件开发，就一定要仔细查看maven的<a href="https://maven.apache.org/plugin-developers/index.html">官方文档</a></em></p>
<h2 id="maven插件示例解读">maven插件示例解读</h2>
<h3 id="spring-boot-maven-plugin">spring-boot-maven-plugin</h3>
<h4 id="前置知识">前置知识</h4>
<p>什么是springboot?通常我们说springboot是对于各种依赖自动配置的boot工具，便于快速开发，避免依赖的困扰，这种方式目前已经不止是springboot的独有，只是它依托与spring生态最为出名而已。</p>
<p>springboot与spring最大的区别在我这个小白看来则是注解开发，@SpringBootApplication定义程序的启动入口，所有的程序都需要依托于这个主类进行加载，而传统的spring项目则需要依托与web容器启动servlet配置，也就WebApplicationInitializer（简单来说是用于将项目中所有的servlet加载到web容器当中，参如http请求当中的rest控制器部分）。</p>
<p>无论如何我们需要明白一个jar包的执行是需要一个入口！而不同项目的入口是不一样！</p>
<p>对于普通jar包来说，他只需要将当前项目的class文件打包即可，而一个可执行的jar包则额外的需要依赖、入口、引导器。（如果稍微了解一点jvm知识就应该明白，java程序并不会在加载阶段去校验import是否存在，至于执行更是需要一个明确的入口。）</p>
<p>可执行jar:</p>
<ul>
<li>将依赖引入jar包当中</li>
<li>META-INF/MANIFEST.MF文件中存在启动类等配置</li>
<li>使用命令<code>java -jar</code> 执行</li>
</ul>
<p>不可执行jar:</p>
<ul>
<li>内部只有项目的class文件</li>
<li>META-INF/MANIFEST.MF文件中不存在启动类等配置</li>
<li>不能使用<code>java -jar</code> 执行。</li>
</ul>
<p>java -jar执行逻辑： JVM会根据MANIFEST.MF文件中的Main-Class属性找到程序的入口点（即主类），然后开始执行该类的main方法</p>
    </div>
  <a href="/posts/maven%E6%8F%92%E4%BB%B6%E6%96%B0%E6%89%8B%E8%A7%A3%E6%83%91/" class="ba b--moon-gray bg-light-gray br2 color-inherit dib f7 hover-bg-moon-gray link mt2 ph2 pv1">read more</a>
  </div>

        
            <div class="mb3 pa4 mid-gray overflow-hidden">
    
      <div class="f6">
        March 12, 2025
      </div>
    
    <h1 class="f3 near-black">
      <a href="/posts/git%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97%E4%B8%80/" class="link black dim">
        git入门系列（一）   
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      <h1 id="git是什么">git是什么？</h1>
<h2 id="以键值数据库为基础的文件版本控制系统">以键值数据库为基础的文件版本控制系统</h2>
<p>参考：https://git-scm.com/book/zh/v2/%e8%b5%b7%e6%ad%a5-Git-%e6%98%af%e4%bb%80%e4%b9%88%ef%bc%9f</p>
<p>提醒： 本篇大部分在git官网都存在，只是顺序不一致，按我理解，这样有助于直接理解git的钩子机制。</p>
<p>传统的文件版本数据库通过累计文件差异来区分文件版本，而git则是通过不断累计文件快照，然后使用链接管理当前版本应该显示的文件！</p>
<ul>
<li>好处：如果存储文件差异，则不可避免的需要从文件内部开始操作，所带来的是复杂且绝不能出错的高安全性要求，而git管理文件链接，换言之，他只需要保存每个版本的文件链接列表即可，对于真实的文件数据，他们互相隔离。</li>
<li>坏处：文件系统容易变得臃肿庞大。</li>
</ul>
<p>参考:https://git-scm.com/book/zh/v2/Git-%e5%86%85%e9%83%a8%e5%8e%9f%e7%90%86-Git-%e5%af%b9%e8%b1%a1</p>
<p>文件快照存储的方式则是键值数据库，位于.git/objects 目录。</p>
<p>存储值，并返回唯一键（SHA-1 哈希值）：<code>echo 'test content' | git hash-object -w --stdin</code></p>
<pre tabindex="0"><code>$ echo &#39;test content&#39; | git hash-object -w --stdin
d670460b4b4aece5915caf5c68d12f560a9fe3e4
</code></pre><p>取出：</p>
<pre tabindex="0"><code>$ git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4
test content
</code></pre><p>此外还有树对象用于组织这些键值。</p>
<p><img src="https://blog.wenzhuo4657.org/img/image-20250312155433934.png" alt="image-20250312155433934"></p>
<p>但是这仍然不是我们所熟知的git commit提交对象，这并没有提交信息的对应，这一点简单的说即是sha-1哈希值和文本的对应。随意找一个仓库都可以看到他们之间的关联。</p>
<p><img src="https://blog.wenzhuo4657.org/img/image-20250312155805995.png" alt="image-20250312155805995"></p>
<h2 id="待补充">待补充</h2>
<h1 id="钩子函数">钩子函数</h1>
<p>git的钩子位于<code>.git\hooks</code>,默认情况下都是.sample结尾，去掉这个后缀即可启用。</p>
<p><img src="https://blog.wenzhuo4657.org/img/image-20250312160203955.png" alt="image-20250312160203955"></p>
<p>尝试打开即可他先，他们都是统一的shell脚本，所以如果想要看懂是需要一点基础的。</p>
<p>统一机制：当以非零退出脚本时，停止提交。</p>
<p>提醒：shell脚本的运行并不是git管理的一部分，他们只是使用了git命令的一段编码，通常使用/bin/bash解释器运行。</p>
<h2 id="pre-commit提交前执行">pre-commit：提交前执行</h2>
<p>作用：当前分支是否存在，如果不存在会提供一个sha-1哈希值。</p>
<p>git rev-parse &ndash;verify HEAD  （该命令可以验证参数是否可以转换为sha-1哈希值，即他是否在对象数据库中有对应关系，常见有分支名、标签名）</p>
<h2 id="prepare-commit-msg提交前执行">prepare-commit-msg：提交前执行</h2>
<p>作用：</p>
<p>1，修改默认提交消息</p>
<p>2，添加gpt签名</p>
<p>3，将 git diff 结果插入提交消息的注释部分（咱不理解，自行查询）</p>
<p>修改默认消息最直接的途径就是在文件末尾<code>echo &quot;default msg&quot; &gt; $1</code>,这样就会覆盖</p>
<p><code>/usr/bin/perl -i.bak -ne 'print unless(m/^. Please enter the commit message/..m/^#$/)' &quot;$COMMIT_MSG_FILE&quot;</code></p>
    </div>
  <a href="/posts/git%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97%E4%B8%80/" class="ba b--moon-gray bg-light-gray br2 color-inherit dib f7 hover-bg-moon-gray link mt2 ph2 pv1">read more</a>
  </div>

        
      
        <h2 class="f1">
          <a href="/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" class="link blue hover-black">
            Category: 源码阅读
          </a>
        </h2>
        
            <div class="mb3 pa4 mid-gray overflow-hidden">
    
      <div class="f6">
        May 14, 2025
      </div>
    
    <h1 class="f3 near-black">
      <a href="/posts/logback%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E4%B8%80/" class="link black dim">
        logback官方文档阅读（一）   
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      <h3 id="logback">logback</h3>
<h4 id="架构">架构</h4>
<p><a href="https://logback.qos.ch">Logback 架构</a>
logback的核心依赖有：logback-core，logback-classic 和 logback-access</p>
<p>core： 核心实现，是其他两个包的基础
classic：
logback-classic 模块可以被同化为 log4j 1.x 的显着改进版本。此外，logback-classic 本机实现了 <a href="http://www.slf4j.org/">SLF4J API</a></p>
<p>access： 与 Servlet 容器（例如 Tomcat 和 Jetty）集成，以提供 HTTP 访问日志功能</p>
<h4 id="配置">配置</h4>
<p>Logback.xml配置的两个重要标签：<code>Logger</code>，<code>Appender</code></p>
<p>logger： 指定日志记录根（全限定类名）和appender的关联
appender： 日志的具体输出实现，例如： 控制台输出、文件输出等</p>
<pre tabindex="0"><code>示例配置

&lt;configuration scan=&#34;true&#34; scanPeriod=&#34;60 seconds&#34; debug=&#34;false&#34;&gt;
&lt;property name=&#34;console&#34; value=&#34;==\n[%-5level] %red(%d{HH:mm}) Thread:[%thread]  Method:%green(%M) %cyan(%X{traceId})   classpath:%c \n%highlight(return):%m%n&#34;&gt;&lt;/property&gt;
&lt;property name=&#34;log_dir&#34; value=&#34;./data/log&#34;&gt;&lt;/property&gt;
    &lt;appender name=&#34;STDOUT&#34; class=&#34;ch.qos.logback.core.ConsoleAppender&#34;&gt;
            &lt;encoder class=&#34;ch.qos.logback.classic.encoder.PatternLayoutEncoder&#34;&gt;
                 &lt;pattern&gt;${console}&lt;/pattern&gt;
                &lt;charset&gt;utf8&lt;/charset&gt;
            &lt;/encoder&gt;
    &lt;/appender&gt;


    &lt;!--html格式日志文件输出appender--&gt;
    &lt;appender name=&#34;SERVICE_APPENDER&#34; class=&#34;ch.qos.logback.core.FileAppender&#34;&gt;
        &lt;!--日志文件保存路径--&gt;
        &lt;file&gt;${log_dir}/logback.html&lt;/file&gt;
        &lt;!--html 消息格式配置--&gt;
        &lt;encoder class=&#34;ch.qos.logback.core.encoder.LayoutWrappingEncoder&#34;&gt;
            &lt;layout class=&#34;ch.qos.logback.classic.html.HTMLLayout&#34;&gt;
            &lt;/layout&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;


        &lt;appender name=&#34;All_APPENDER&#34; class=&#34;ch.qos.logback.core.rolling.RollingFileAppender&#34;&gt;
            &lt;file&gt;${log_dir}/All/demo.log&lt;/file&gt;
            &lt;encoder&gt;
                &lt;pattern&gt;%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt;
            &lt;/encoder&gt;
            &lt;rollingPolicy class=&#34;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&#34;&gt;
                &lt;fileNamePattern&gt;${log_dir}/All/demo.%d{yyyy-MM-dd}.log&lt;/fileNamePattern&gt;
            &lt;/rollingPolicy&gt;

    &lt;/appender&gt;



&lt;!--    &lt;/appender&gt;--&gt;

    &lt;root level=&#34;DEBUG&#34;&gt;
        &lt;appender-ref ref=&#34;STDOUT&#34;/&gt;
        &lt;appender-ref ref=&#34;All_APPENDER&#34;&gt;&lt;/appender-ref&gt;
        &lt;appender-ref ref=&#34;SERVICE_APPENDER&#34;/&gt;
    &lt;/root&gt;



        &lt;logger name=&#34;org/example&#34; level=&#34;ERROR&#34; additivity=&#34;true&#34;&gt;
            &lt;appender-ref ref=&#34;SERVICE_APPENDER&#34;/&gt;
        &lt;/logger&gt;

&lt;/configuration&gt;
</code></pre><h3 id="官网文档阅读">官网文档阅读</h3>
<p><a href="https://logback.qos.ch/manual/introduction.html">文档首页</a></p>
    </div>
  <a href="/posts/logback%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E4%B8%80/" class="ba b--moon-gray bg-light-gray br2 color-inherit dib f7 hover-bg-moon-gray link mt2 ph2 pv1">read more</a>
  </div>

        
      
        <h2 class="f1">
          <a href="/categories/%E6%BA%90%E7%A0%81/" class="link blue hover-black">
            Category: 源码
          </a>
        </h2>
        
            <div class="mb3 pa4 mid-gray overflow-hidden">
    
      <div class="f6">
        April 16, 2025
      </div>
    
    <h1 class="f3 near-black">
      <a href="/posts/rocketmq%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%80%E7%94%9F%E4%BA%A7%E8%80%85%E5%88%9D%E8%AF%86/" class="link black dim">
        rocketmq源码阅读（一）：生产者初识   
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      <h1 id="源码阅读一">源码阅读（一）</h1>
<h2 id="搭建环境">搭建环境</h2>
<p>rocketmq的java-sdk并没有什么特殊的构建的，直接加载maven即可。</p>
<p>节点部署：
<a href="https://rocketmq.apache.org/zh/docs/quickStart/02quickstartWithDocker">Docker 部署 RocketMQ | RocketMQ</a></p>
<p>面板部署：
<a href="https://github.com/apache/rocketmq-dashboard">apache/rocketmq-dashboard</a></p>
<p>hhh，遵从官网部署，点点点就可以了。</p>
<h2 id="生产者初识">生产者初识</h2>
<p>阅读源码首先要明确的目标，或者说我们想要了解什么？</p>
<p>在我看来生产者的职责分为以下几个</p>
<ul>
<li>1,与<code>namesrv</code>沟通，维护本地的<code>broker</code>通信队列</li>
<li>2,发送<code>topic</code>消息到远程<code>broker</code></li>
<li>3,根据响应结果判断是否发送成功，以及失败情况下的策略</li>
</ul>
<p>每一个生产者对于<code>broker</code>节点来说是消息的来源，但是<code>broker</code>并不关心究竟有多少个生产者在为它提供服务，对于消费者来说同样如此！</p>
<p>首先定位到源码示例</p>
<p><img src="%5Bhttps://blog.wenzhuo4657.org/img/2025/04/ce5a9ce6d095400e1dfefe77486c2729.png" alt=""></p>
<p>示例的逻辑并不复杂，但问题是怎么处理的？尝试追溯<code>DefaultMQProducer</code>,找到客户端的sdk模块<code>rocketmq-client</code></p>
<p>观察<code>DefaultMQProducer</code>的父类路径发现<code>extends ClientConfig implements MQProducer</code>,对于<code>MQProducer</code>没啥好说的，定义了生产者方法规范，而且没有注释。小白一只的我将目光对准<code>ClientConfig</code>,</p>
<p><code>private String clientIP = NetworkUtil.getLocalAddress();</code>  寻找ip的方法。</p>
<p><code>private String instanceName = System.getProperty(&quot;rocketmq.client.name&quot;, &quot;DEFAULT&quot;);</code>  生产者名称</p>
<pre tabindex="0"><code>    # 客户端id，这个要注意与生产者名称区分，在我看来是类似与多元组一样的， ip+instanceName+......
   
    public String buildMQClientId() {
        StringBuilder sb = new StringBuilder();
        sb.append(this.getClientIP());

        sb.append(&#34;@&#34;);
        sb.append(this.getInstanceName());
        if (!UtilAll.isBlank(this.unitName)) {
            sb.append(&#34;@&#34;);
            sb.append(this.unitName);
        }

        if (enableStreamRequestType) {
            sb.append(&#34;@&#34;);
            sb.append(RequestType.STREAM);
        }

        return sb.toString();
    }
    
</code></pre><p>需要注意的是对于修改<code>clentIP</code>可以直接通过<code>producer.setClientIP(DEFAULT_NAMESRVADDR);</code>,<code>clientID</code>则并没有这个字段，他是在生产者启动时自动生成的的一个标识符，或许可以这么说 <code>ip+instanceName</code>表示了这个主机上的所有rocketmq的消费者和生产者。</p>
<p>追溯<code>buildMQClientId</code>即可发现，start的调用链路中存在这个方法。</p>
    </div>
  <a href="/posts/rocketmq%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%80%E7%94%9F%E4%BA%A7%E8%80%85%E5%88%9D%E8%AF%86/" class="ba b--moon-gray bg-light-gray br2 color-inherit dib f7 hover-bg-moon-gray link mt2 ph2 pv1">read more</a>
  </div>

        
            <div class="mb3 pa4 mid-gray overflow-hidden">
    
      <div class="f6">
        March 10, 2025
      </div>
    
    <h1 class="f3 near-black">
      <a href="/posts/tomcat%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%BA%8C/" class="link black dim">
        tomcat源码阅读（二）   
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      <h1 id="tomcat源码阅读">tomcat源码阅读</h1>
<h2 id="日志模块梳理">日志模块梳理</h2>
<p>现在日志通常分为日志门面和日志的具体实现。</p>
<p>日志门面：充当应用程序和日志框架之间的沟通媒介，可以在程序无感的条件下更换日志框架。</p>
<p>日志的具体实现：直接记录日志(console、file)，并且需要注意的是，这些信息都是由日志门面交给日志实现的。</p>
<p>对于非日志编程的程序员来说，我们只需要明白如何根据日志门面切换日志实现即可，没必要阅读日志实现的代码。</p>
<p>常见的日志门面：JCL、slf4j</p>
<p>常见的日志实现：JUL（java.util.logging）、log4j、logback、log4j2</p>
<h3 id="tomcat的日志门面juli">tomcat的日志门面JULI</h3>
<p>该日志门面位于源码包<code>org.apache.juli</code>,基于JCL实现的。</p>
<p>较为重要的三个类：</p>
<p>org.apache.juli.logging.Log： 日志接口</p>
<p>org.apache.juli.logging.DirectJDKLog：tomcat的默认日志实现。</p>
<p>org.apache.juli.logging.LogFactory: 与tomcat进行交互获取log接口实现。</p>
<p>在源码中可以看到，无论是什么类要记录日志都必须使用到Log的实现类，而对于tomcat源码来说，唯一获取该实例的途径就是LogFactory#getLog(Class<!-- raw HTML omitted --> clazz)。</p>
<p>并且在LogFactory#release(ClassLoader classLoader)也可以看到日志实现默认为JUL,硬编码控制的。</p>
<pre tabindex="0"><code>    public static void release(ClassLoader classLoader) {
        // JULI&#39;s log manager looks at the current classLoader so there is no
        // need to use the passed in classLoader, the default implementation
        // does not so calling reset in that case will break things
        if (!LogManager.getLogManager().getClass().getName().equals(
                &#34;java.util.logging.LogManager&#34;)) {
            LogManager.getLogManager().reset();
        }
    }
</code></pre><h2 id="关于日志实现log的加载">关于日志实现log的加载</h2>
<p>在LogFactory的无参构造器器中看到关键语句</p>
    </div>
  <a href="/posts/tomcat%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%BA%8C/" class="ba b--moon-gray bg-light-gray br2 color-inherit dib f7 hover-bg-moon-gray link mt2 ph2 pv1">read more</a>
  </div>

        
            <div class="mb3 pa4 mid-gray overflow-hidden">
    
      <div class="f6">
        March 7, 2025
      </div>
    
    <h1 class="f3 near-black">
      <a href="/posts/tomcat%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%80/" class="link black dim">
        tomcat源码阅读（一）   
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      <h1 id="tomcat源码">tomcat源码</h1>
<h2 id="idea环境搭建">idea环境搭建</h2>
<p>源码版本apache-tomcat-9.0.43-src</p>
<p><a href="https://archive.apache.org/dist/tomcat/tomcat-9/v9.0.43/src/">https://archive.apache.org/dist/tomcat/tomcat-9/v9.0.43/src/</a></p>
<p>注意： 不同版本的搭建方式可能略有不同，但这源码核心是大差不差的。</p>
<h3 id="安装ant已安装的可以直接跳过">安装ant(已安装的可以直接跳过)</h3>
<p>Apache Ant 是一个帮助构建软件的 Java 库和命令行工具。</p>
<p>官网：https://ant.apache.org/bindownload.cgi</p>
<p>直接下载最新版即可，解压之后设置环境变量</p>
<pre tabindex="0"><code>ANT_HOME=/Library/Apache/apache-ant-1.9.15
PATH=$PATH:$ANT_HOME/bin
</code></pre><p>使用<code>ant -verison</code>验证安装是否成功</p>
<p><img src="https://blog.wenzhuo4657.org/img/image-20250307171403529.png" alt="image-20250307171403529"></p>
<h3 id="构建项目">构建项目</h3>
<p><em>在打开idea之前操作，这一点非常重要！！！否则会由于编译器的一些操作导致XXXXX</em></p>
<p>直接将res目录idea-support中的.idea文件粘贴到根目录中的.idea（手动创建</p>
<p><img src="https://blog.wenzhuo4657.org/img/image-20250309134412453.png" alt="image-20250309134412453"></p>
<p><img src="https://blog.wenzhuo4657.org/img/image-20250309134454556.png" alt="image-20250309134454556"></p>
<p><img src="https://blog.wenzhuo4657.org/img/image-20250309134544101.png" alt="image-20250309134544101"></p>
<p>此时打开项目可以发现项目被正确加载，但是会依赖报错</p>
<p><img src="https://blog.wenzhuo4657.org/img/image-20250309135659189.png" alt="image-20250309135659189"></p>
<p>尝试构建项目，启动test</p>
<p><img src="https://blog.wenzhuo4657.org/img/image-20250309135743059.png" alt="image-20250309135743059"></p>
<p><img src="https://blog.wenzhuo4657.org/img/image-20250309134654470.png" alt="image-20250309134654470"></p>
<p>将这些jar包和ant目录下的lib库加入项目的外部库即可。</p>
<p><img src="https://blog.wenzhuo4657.org/img/image-20250309141125493.png" alt="image-20250309141125493"></p>
<h2 id="启动">启动</h2>
<p>找到启动类Bootstrap</p>
<p><img src="https://blog.wenzhuo4657.org/img/image-20250309141245515.png" alt="image-20250309141245515"></p>
<p><img src="https://blog.wenzhuo4657.org/img/image-20250309141253099.png" alt="image-20250309141253099"></p>
<h1 id="中文乱码">中文乱码</h1>
<p>对于乱码，网上搜索在日志配置中更改编码，</p>
<p><a href="https://blog.csdn.net/weixin_44109450/article/details/126544310">https://blog.csdn.net/weixin_44109450/article/details/126544310</a></p>
<p>但是对于源码编译环境来说，似乎并不会读取conf下的配置，追溯源码找到<code>java.util.logging.ConsoleHandler</code>.</p>
<p>断点调试发现，并没有获取到配置</p>
<p><img src="https://blog.wenzhuo4657.org/img/image-20250309142742777.png" alt="image-20250309142742777"></p>
<p>并且由于该类属于依赖包jdk的一部分，<img src="https://blog.wenzhuo4657.org/img/image-20250309142835530.png" alt="image-20250309142835530"></p>
<p>进一步追溯之后发现关键读取文件的方法LogManager#readConfiguration（）</p>
<pre tabindex="0"><code>   String fname = System.getProperty(&#34;java.util.logging.config.file&#34;);
        if (fname == null) {
            fname = System.getProperty(&#34;java.home&#34;);
            if (fname == null) {
                throw new Error(&#34;Can&#39;t find java.home ??&#34;);
            }
            File f = new File(fname, &#34;lib&#34;);
            f = new File(f, &#34;logging.properties&#34;);
            fname = f.getCanonicalPath();
        }
        try (final InputStream in = new FileInputStream(fname)) {
            final BufferedInputStream bin = new BufferedInputStream(in);
            readConfiguration(bin);
        }
</code></pre><p>首先说结论，无论使更改成conf还是jdk目录下的logging.properties,他们所影响的编码都只是外层的一部分，不能影响tomcat输出的报错信息。</p>
    </div>
  <a href="/posts/tomcat%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%80/" class="ba b--moon-gray bg-light-gray br2 color-inherit dib f7 hover-bg-moon-gray link mt2 ph2 pv1">read more</a>
  </div>

        
      
        <h2 class="f1">
          <a href="/categories/springboot/" class="link blue hover-black">
            Category: Springboot
          </a>
        </h2>
        
            <div class="mb3 pa4 mid-gray overflow-hidden">
    
      <div class="f6">
        March 29, 2025
      </div>
    
    <h1 class="f3 near-black">
      <a href="/posts/%E5%85%B3%E4%BA%8E-requestparam%E7%9A%84%E5%B8%B8%E8%A7%81%E8%AF%AF%E5%8C%BA/" class="link black dim">
        关于@RequestParam的常见误区   
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      <p>首先说结论，@RequestParam不仅可以结束queryString的参数，还可以接收表单数据。</p>
<h2 id="关于http载荷的区分">关于http载荷的区分</h2>
<ul>
<li>
<p>queryString</p>
<p><code>http://example.com/path?key1=value1&amp;key2=value2&amp;key3=value3</code></p>
<p>无论是get还是post，他在url上的表现都是上述，而关于get和post的区别主要显示在http报文上字段填充。</p>
<pre tabindex="0"><code>GET /search?q=springboot&amp;page=1 HTTP/1.1
Host: example.com
Accept: application/json
</code></pre><pre tabindex="0"><code>路径和请求体可以共存，但是他们都统一可以使用作为queryString参数进行键值对解析。
POST /submit?id=123 HTTP/1.1
Host: example.com
Content-Type: application/json

{&#34;name&#34;: &#34;Alice&#34;}
</code></pre></li>
</ul>
<p>事实上，queryStirng参数的核心在于键值，而不是位于请求体、路径。</p>
<ul>
<li>
<p>multipart/form-data</p>
<p>文件上传</p>
</li>
<li>
<p>application/x-www-form-urlencoded</p>
<p>表单文件</p>
</li>
</ul>
    </div>
  <a href="/posts/%E5%85%B3%E4%BA%8E-requestparam%E7%9A%84%E5%B8%B8%E8%A7%81%E8%AF%AF%E5%8C%BA/" class="ba b--moon-gray bg-light-gray br2 color-inherit dib f7 hover-bg-moon-gray link mt2 ph2 pv1">read more</a>
  </div>

        
      
        <h2 class="f1">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" class="link blue hover-black">
            Category: 数据结构与算法
          </a>
        </h2>
        
            <div class="mb3 pa4 mid-gray overflow-hidden">
    
      <div class="f6">
        March 18, 2025
      </div>
    
    <h1 class="f3 near-black">
      <a href="/posts/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%A2%B3%E7%90%86/" class="link black dim">
        八大排序算法梳理   
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      <p>本篇blog的语言为java实现，介意请划走</p>
<h1 id="八大排序算法">八大排序算法</h1>
<ul>
<li>冒泡排序</li>
<li>选择排序</li>
<li>插入排序</li>
<li>希尔排序</li>
<li>快速排序</li>
<li>归并排序</li>
<li>桶排序</li>
<li>堆排序</li>
</ul>
<p>上述排序值得注意的是堆排序，他利用顺序二叉树实现了对堆元素的随机存取，而他所操作的虽然是数组结构，但本质上我们将其视为一个二叉树。</p>
<h2 id="基本排序算法并不复杂甚至称不上算法理解即可">基本排序算法（并不复杂，甚至称不上算法，理解即可）</h2>
<h3 id="冒泡">冒泡</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">bubble_sort</span>(<span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> arr) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> i, j, temp, len <span style="color:#f92672">=</span> arr.<span style="color:#a6e22e">length</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> 0; i <span style="color:#f92672">&lt;</span> len <span style="color:#f92672">-</span> 1; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">for</span> (j <span style="color:#f92672">=</span> 0; j <span style="color:#f92672">&lt;</span> len <span style="color:#f92672">-</span> 1 <span style="color:#f92672">-</span> i; j<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> (arr<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">&gt;</span> arr<span style="color:#f92672">[</span>j <span style="color:#f92672">+</span> 1<span style="color:#f92672">]</span>) {
</span></span><span style="display:flex;"><span>					temp <span style="color:#f92672">=</span> arr<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>					arr<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> arr<span style="color:#f92672">[</span>j <span style="color:#f92672">+</span> 1<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>					arr<span style="color:#f92672">[</span>j <span style="color:#f92672">+</span> 1<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> temp;
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>时间复杂度（n^2）</p>
<p>每次排序将最大值放入末尾，且注意，该算法的核心在于逐步排序，内层循环将较小或者较大的值下沉。</p>
<h3 id="选择排序">选择排序</h3>
<p>在冒泡排序中，我们逐步将最大或最小值后移，而选择排序优化了这个过程，比较过程并不移动数组元素，而是先找到将要移动的坐标。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Description: 选择排序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @param array
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @return void
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @author JourWon
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @date 2019/7/11 23:31
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">selectionSort</span>(<span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> array) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (array <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> array.<span style="color:#a6e22e">length</span> <span style="color:#f92672">&lt;=</span> 1) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> length <span style="color:#f92672">=</span> array.<span style="color:#a6e22e">length</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0; i <span style="color:#f92672">&lt;</span> length <span style="color:#f92672">-</span> 1; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 保存最小数的索引</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> minIndex <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> 1; j <span style="color:#f92672">&lt;</span> length; j<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 找到最小的数</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (array<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">&lt;</span> array<span style="color:#f92672">[</span>minIndex<span style="color:#f92672">]</span>) {
</span></span><span style="display:flex;"><span>				minIndex <span style="color:#f92672">=</span> j;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 交换元素位置</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (i <span style="color:#f92672">!=</span> minIndex) {
</span></span><span style="display:flex;"><span>			swap(array, minIndex, i);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Description: 交换元素位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @param array
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @param a
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @param b
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @return void
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @author JourWon
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @date 2019/7/11 17:57
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">swap</span>(<span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> array, <span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> temp <span style="color:#f92672">=</span> array<span style="color:#f92672">[</span>a<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>	array<span style="color:#f92672">[</span>a<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> array<span style="color:#f92672">[</span>b<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>	array<span style="color:#f92672">[</span>b<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> temp;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="插入排序">插入排序</h3>
<p>该思想和动态规划有点像，即我们假定要将插入某个元素插入一个有序数组，那么我们只需要从数组起点或者某位逐步比较即可。</p>
    </div>
  <a href="/posts/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%A2%B3%E7%90%86/" class="ba b--moon-gray bg-light-gray br2 color-inherit dib f7 hover-bg-moon-gray link mt2 ph2 pv1">read more</a>
  </div>

        
      
        <h2 class="f1">
          <a href="/categories/os/" class="link blue hover-black">
            Category: OS
          </a>
        </h2>
        
            <div class="mb3 pa4 mid-gray overflow-hidden">
    
      <div class="f6">
        February 15, 2025
      </div>
    
    <h1 class="f3 near-black">
      <a href="/posts/%E9%9B%B6%E6%8B%B7%E8%B4%9D/" class="link black dim">
        零拷贝   
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      <p>首先说结论，零拷贝技术是针对与磁盘中数据到网卡发送数据的一个简化，是系统函数级别的优化，与程序编程无关，在使用中我们只需要调用即可。</p>
<h2 id="系统拷贝-readwrite">系统拷贝 read/write</h2>
<p>前置概念：</p>
<ul>
<li>页缓存（内核缓冲区）：该区域是为了提升磁盘数据的读写速度所设立的一个区域，处于（主存）内存当中。</li>
<li>socket缓冲区：是内核为每个 Socket 分配的内存区域，用于临时存储发送和接收的数据，处于（主存）内存当中。</li>
</ul>
<p>os系统的加载，学过操作系统的都知道，内存当中的区域分为内核态和用户态。</p>
<p>在操作系统启动时，cpu会根据cs:ip表示的地址进行寻址，找到位于磁盘当中的操作系统程序部分，最终结果可以认为将系统代码搬进了ram主存当中，并且设置了一些列安全手段，除此之外则还为用户态提供了一系列系统函数。</p>
<p><strong>磁盘== “外设”</strong>：</p>
<p>对于cpu来说，磁盘相当于外设，它会通过外设上的寄存器来管理，此处衍生出的技术为dma。</p>
<ul>
<li>dma:为了避免cpu的重复性的移动地址等的操作，进行的一项优化，具体来说，读取数据到缓冲区等重复性劳动可以交给dma设备。</li>
</ul>
<p>但是dma拷贝也并非万能，在某些场景下它不能使用</p>
<ul>
<li>用户空间和内核空间之间的数据拷贝：内核不能直接访问用户态内存</li>
<li>调试和诊断：dma是硬件自动完成，难以插入调试逻辑。</li>
</ul>
<p><img src="http://blog.wenzhuo4657.org/img/image-20250215171022865.png" alt="image-20250215171022865"></p>
<h1 id="系统函数">系统函数</h1>
<h2 id="mmapwrite">mmap+write</h2>
<p>将page buffer和程序工作缓存空间进行映射，减少page-buffer-&gt;程序缓存的cpu拷贝，但是对于程序工作缓存-》socket buffer这一部分仍然需要cpu拷贝。</p>
<p><strong>为什么仍然是cpu拷贝？</strong></p>
<p>这里将其理解为，我们仅仅是做到了在用户态可以看到page buffer,但是并没有打破用户态和内核态的内存空间限制，所以此处的拷贝仍然是cpu拷贝，而并非dma拷贝。</p>
<p><img src="https://blog.wenzhuo4657.org/img/image-20250215172019525.png" alt="image-20250215172019525"></p>
<h2 id="sendfile">sendfile</h2>
<p><img src="https://blog.wenzhuo4657.org/img/image-20250215172632051.png" alt="image-20250215172632051"></p>
<p>如图，sendfile使page buff直接拷贝到socket buffer。</p>
<p><strong>为什么使用的使cpu拷贝，而非DMA拷贝？</strong></p>
<p>ds给我的答案使，DMA通常用于外设和主存之间，</p>
<h2 id="网卡支持sg-dma技术的sendfile">网卡支持SG-DMA技术的sendfile</h2>
<p><img src="https://blog.wenzhuo4657.org/img/image-20250215173227238.png" alt="image-20250215173227238"></p>
<p>如图，该函数实际上是外设功能的调用，原本socket buffer的功能被网卡认为多余，获取可以被替代之类的，提出直接从page buffer中拷贝。</p>
<h1 id="总结">总结</h1>
<p>实际应用：</p>
<p>普通的文件读写：read/write,有利于提高系统速度，但这是非具体场景的随机读取。</p>
<p>rocketmq: mmap+write，适合小文件并行，因为该区域用户缓存都可以看到。</p>
<p>kafka:sendfile,适合大文件，或者说对于小文件并行支持不好，因为为了安全性，通常会对page buffer进行锁定，避免并发问题。</p>
<p>ps:上述总结可以喂给ds，会得到更加优质的回答！</p>
    </div>
  <a href="/posts/%E9%9B%B6%E6%8B%B7%E8%B4%9D/" class="ba b--moon-gray bg-light-gray br2 color-inherit dib f7 hover-bg-moon-gray link mt2 ph2 pv1">read more</a>
  </div>

        
      
        <h2 class="f1">
          <a href="/categories/dubbo/" class="link blue hover-black">
            Category: Dubbo
          </a>
        </h2>
        
            <div class="mb3 pa4 mid-gray overflow-hidden">
    
      <div class="f6">
        January 22, 2025
      </div>
    
    <h1 class="f3 near-black">
      <a href="/posts/dubbo%E7%9A%84spi/" class="link black dim">
        dubbo的spi   
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      <p>dubbo的spi相比于jdk的spi而言，提供了更为强大的功能，主要来说是帮助我们更好的面对多个服务互相依赖的场景，并且做了一定优化。（例如：按需加载）</p>
<h2 id="按需加载">按需加载</h2>
<p>jdk的spi的配置文件</p>
<pre tabindex="0"><code>org.example.ToyotaCar
org.example.HondaCar
</code></pre><p>dubbo的spi的配置文件</p>
<pre tabindex="0"><code>toyota=org.example.ToyotaCar
honda=org.example.HondaCar
wrapper=org.example.aop.CarWrapper1
wrapper=org.example.aop.CarWrapper2
Race=org.example.ioc.RaceRes
red=org.example.ioc.PenRes
</code></pre><p>二者的区别在于dubbo中使用键值，可以实现按需加载，请注意，该加载并非指配置文件的加载，而加载配置文件之后的对于<strong>服务对象的实例化</strong>。</p>
<h3 id="示例">示例</h3>
<h4 id="jdk的spi">jdk的spi</h4>
<pre tabindex="0"><code>      ServiceLoader&lt;Car&gt; load = ServiceLoader.load(Car.class);

//        获取迭代器遍历
        Iterator&lt;Car&gt; iterator = load.iterator();
        while (iterator.hasNext()){
            Car registry = iterator.next();
            registry.run();
        }
        
</code></pre><p>追溯源码可以看到迭代器内部。</p>
<p><img src="https://blog.wenzhuo4657.org/img/image-20250122174648892.png" alt="image-20250122174648892"></p>
<p>关键成员变量</p>
<p>Iterator<!-- raw HTML omitted --> pending ;//配置文件读取的数据  <strong>该变量也是迭代器</strong>
String nextName ;//下一个将要读取的配置</p>
<p>存在关键方法</p>
<p>hasNextService：用于判断下一个服务名称，即配置文件当中的全限定类名。</p>
<pre tabindex="0"><code>       private boolean hasNextService() {
            if (nextName != null) {
                return true;
            }
            if (configs == null) {
                try {
                    String fullName = PREFIX + service.getName();
                    if (loader == null)
                        configs = ClassLoader.getSystemResources(fullName);
                    else
                        configs = loader.getResources(fullName);
                } catch (IOException x) {
                    fail(service, &#34;Error locating configuration files&#34;, x);
                }
            }
            while ((pending == null) || !pending.hasNext()) {
                if (!configs.hasMoreElements()) {
                    return false;
                }
                pending = parse(service, configs.nextElement());
            }
            nextName = pending.next();//获取下一个元素，
            return true;
        }
</code></pre><p>nextService：</p>
    </div>
  <a href="/posts/dubbo%E7%9A%84spi/" class="ba b--moon-gray bg-light-gray br2 color-inherit dib f7 hover-bg-moon-gray link mt2 ph2 pv1">read more</a>
  </div>

        
      
        <h2 class="f1">
          <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF/" class="link blue hover-black">
            Category: 设计思路
          </a>
        </h2>
        
            <div class="mb3 pa4 mid-gray overflow-hidden">
    
      <div class="f6">
        January 21, 2025
      </div>
    
    <h1 class="f3 near-black">
      <a href="/posts/%E5%8D%95%E8%B7%AF%E5%88%86%E5%8F%91%E5%92%8C%E5%A4%9A%E8%B7%AF%E5%88%86%E5%8F%91/" class="link black dim">
        单路分发和多路分发   
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      <h1 id="单路分发">单路分发</h1>
<p>前置概念：
接收者对象：方法调用的目标对象
动态链接：在Java源文件被编译到字节码文件时，所有的变量和方法引用都作为符号引用保存在<strong>class文件的常量池</strong>里。
引用类型/静态类型：java对象的声明类型
运行类型：jvm中对象的实际类型，是堆区数据的对象类型。</p>
<p>java对象的多态性导致其引用类型和运行类型两者的区分，且各自的方法可能出现重写的现象，因而在对象执行过程中需要找到正确的方法。jvm只有在运行阶段才会创建对象，调用方法时根据动态链接找到堆区的方法实现。。</p>
<p>java单路分发：接收者对象（实际上是指堆区创建的对象，也就是运行类型）调用方法时根据动态链接找到方法区的真正实现。</p>
<p>单路分发定义：查找方法只能根据接收者对象判断，而不考虑方法参数的实际类型。</p>
<p>例如：<code>string.valueof(bi)</code> 接收者对象为string,单路分发只会考虑方法参数的引用类型，而非实际类型。</p>
<p>注意：我们说java方法调用是单路分发，不考虑方法参数的<strong>实际类型</strong>。其中对于实际类型的理解需要和重载相区分，因为重载是从参数的引用类型进行选择。而我们所说的单路分发、多路分发实际上是根据方法的实际运行类型进行选择方法的具体实现（动态链接），而java的机制仅仅只支持根据接受者对象来选择方法的动态链接，因此java的分发机制是单路分发。</p>
<ul>
<li>方法重载的匹配：编译器在编译时根据参数类型选择最匹配的方法。</li>
<li>编译器生成的字节码：编译器将方法调用转换为字节码指令，这些指令包含了方法调用的具体信息。</li>
<li>动态链接：在类加载时，方法引用被解析为具体的方法地址。在方法调用时，JVM 根据接收者对象的实际类型选择具体的方法实现。</li>
</ul>
<h1 id="两路分发和多路分发">两路分发和多路分发</h1>
<p>参考;<a href="https://www.cnblogs.com/Yee-Q/p/14035322.html">Java 枚举 enum 详解 - 低吟不作语 - 博客园</a></p>
<p>java实现两路分发实际上就是在方法调用中再次触发方法调用，根据方法参数的实际类型进行选择方法。</p>
<p>硬编码实现</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">##</span> 可以使用枚举<span style="color:#960050;background-color:#1e0010">、</span>swich简化代码实现
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@Override</span> <span style="color:#66d9ef">public</span> Outcome <span style="color:#a6e22e">compete</span>(Item it) 
</span></span><span style="display:flex;"><span>{ <span style="color:#66d9ef">return</span> 
</span></span><span style="display:flex;"><span>it.<span style="color:#a6e22e">eval</span>(<span style="color:#66d9ef">this</span>); 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>且注意，只有<code>it.eveal(this)</code>找到的方法才是期望的方法，第一次执行找到compete方法是实现两路分发的过程。</p>
<p>EnumMap 实现：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">package</span> enums;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.*;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import static</span> enums.Outcome.*;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> RoShamBo5 <span style="color:#66d9ef">implements</span> Competitor<span style="color:#f92672">&lt;</span>RoShamBo5<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    PAPER, SCISSORS, ROCK;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> EnumMap<span style="color:#f92672">&lt;</span>RoShamBo5,EnumMap<span style="color:#f92672">&lt;</span>RoShamBo5,Outcome<span style="color:#f92672">&gt;&gt;</span>
</span></span><span style="display:flex;"><span>            table <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> EnumMap<span style="color:#f92672">&lt;&gt;</span>(RoShamBo5.<span style="color:#a6e22e">class</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(RoShamBo5 it : RoShamBo5.<span style="color:#a6e22e">values</span>())
</span></span><span style="display:flex;"><span>            table.<span style="color:#a6e22e">put</span>(it, <span style="color:#66d9ef">new</span> EnumMap<span style="color:#f92672">&lt;&gt;</span>(RoShamBo5.<span style="color:#a6e22e">class</span>));
</span></span><span style="display:flex;"><span>        initRow(PAPER, DRAW, LOSE, WIN);
</span></span><span style="display:flex;"><span>        initRow(SCISSORS, WIN, DRAW, LOSE);
</span></span><span style="display:flex;"><span>        initRow(ROCK, LOSE, WIN, DRAW);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">initRow</span>(RoShamBo5 it,
</span></span><span style="display:flex;"><span>                        Outcome vPAPER, Outcome vSCISSORS, Outcome vROCK) {
</span></span><span style="display:flex;"><span>        EnumMap<span style="color:#f92672">&lt;</span>RoShamBo5,Outcome<span style="color:#f92672">&gt;</span> row <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>                RoShamBo5.<span style="color:#a6e22e">table</span>.<span style="color:#a6e22e">get</span>(it);
</span></span><span style="display:flex;"><span>        row.<span style="color:#a6e22e">put</span>(RoShamBo5.<span style="color:#a6e22e">PAPER</span>, vPAPER);
</span></span><span style="display:flex;"><span>        row.<span style="color:#a6e22e">put</span>(RoShamBo5.<span style="color:#a6e22e">SCISSORS</span>, vSCISSORS);
</span></span><span style="display:flex;"><span>        row.<span style="color:#a6e22e">put</span>(RoShamBo5.<span style="color:#a6e22e">ROCK</span>, vROCK);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Outcome <span style="color:#a6e22e">compete</span>(RoShamBo5 it) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> table.<span style="color:#a6e22e">get</span>(<span style="color:#66d9ef">this</span>).<span style="color:#a6e22e">get</span>(it);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) {
</span></span><span style="display:flex;"><span>        RoShamBo.<span style="color:#a6e22e">play</span>(RoShamBo5.<span style="color:#a6e22e">class</span>, 20);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>实际上依旧是二次选择，只是没有触发方法的动态链接机制，而是通过map类型手动填充了一张表格进行分发。</p>
    </div>
  <a href="/posts/%E5%8D%95%E8%B7%AF%E5%88%86%E5%8F%91%E5%92%8C%E5%A4%9A%E8%B7%AF%E5%88%86%E5%8F%91/" class="ba b--moon-gray bg-light-gray br2 color-inherit dib f7 hover-bg-moon-gray link mt2 ph2 pv1">read more</a>
  </div>

        
      
    </section>
  </div>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white white-70 dn dib-ns pv2 ph3 no-underline" href="http://localhost:1313/" >
    &copy;  猢狲 2025 
  </a>
    <div><div class="ananke-socials"></div>
</div>
  </div>
</footer>

  </body>
</html>
