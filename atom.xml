<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://wenzhuo4657.org/atom.xml" rel="self"/>
  
  <link href="http://wenzhuo4657.org/"/>
  <updated>2025-05-14T00:19:47.174Z</updated>
  <id>http://wenzhuo4657.org/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>logback官方文档阅读（一）</title>
    <link href="http://wenzhuo4657.org/2025/05/14/logback%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://wenzhuo4657.org/2025/05/14/logback%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2025-05-14T00:18:43.000Z</published>
    <updated>2025-05-14T00:19:47.174Z</updated>
    
    <content type="html"><![CDATA[<h3 id="logback"><a href="#logback" class="headerlink" title="logback"></a>logback</h3><h4 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h4><p><a href="https://logback.qos.ch/">Logback 架构</a><br>logback的核心依赖有：logback-core，logback-classic 和 logback-access</p><p>core： 核心实现，是其他两个包的基础<br>classic：<br>logback-classic 模块可以被同化为 log4j 1.x 的显着改进版本。此外，logback-classic 本机实现了 <a href="http://www.slf4j.org/">SLF4J API</a></p><p>access： 与 Servlet 容器（例如 Tomcat 和 Jetty）集成，以提供 HTTP 访问日志功能</p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>Logback.xml配置的两个重要标签：<code>Logger</code>，<code>Appender</code></p><p>logger： 指定日志记录根（全限定类名）和appender的关联<br>appender： 日志的具体输出实现，例如： 控制台输出、文件输出等</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">示例配置</span><br><span class="line"></span><br><span class="line">&lt;configuration scan=&quot;true&quot; scanPeriod=&quot;60 seconds&quot; debug=&quot;false&quot;&gt;</span><br><span class="line">&lt;property name=&quot;console&quot; value=&quot;==\n[%-5level] %red(%d&#123;HH:mm&#125;) Thread:[%thread]  Method:%green(%M) %cyan(%X&#123;traceId&#125;)   classpath:%c \n%highlight(return):%m%n&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;property name=&quot;log_dir&quot; value=&quot;./data/log&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;</span><br><span class="line">            &lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt;</span><br><span class="line">                 &lt;pattern&gt;$&#123;console&#125;&lt;/pattern&gt;</span><br><span class="line">                &lt;charset&gt;utf8&lt;/charset&gt;</span><br><span class="line">            &lt;/encoder&gt;</span><br><span class="line">    &lt;/appender&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!--html格式日志文件输出appender--&gt;</span><br><span class="line">    &lt;appender name=&quot;SERVICE_APPENDER&quot; class=&quot;ch.qos.logback.core.FileAppender&quot;&gt;</span><br><span class="line">        &lt;!--日志文件保存路径--&gt;</span><br><span class="line">        &lt;file&gt;$&#123;log_dir&#125;/logback.html&lt;/file&gt;</span><br><span class="line">        &lt;!--html 消息格式配置--&gt;</span><br><span class="line">        &lt;encoder class=&quot;ch.qos.logback.core.encoder.LayoutWrappingEncoder&quot;&gt;</span><br><span class="line">            &lt;layout class=&quot;ch.qos.logback.classic.html.HTMLLayout&quot;&gt;</span><br><span class="line">            &lt;/layout&gt;</span><br><span class="line">        &lt;/encoder&gt;</span><br><span class="line">    &lt;/appender&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &lt;appender name=&quot;All_APPENDER&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;</span><br><span class="line">            &lt;file&gt;$&#123;log_dir&#125;/All/demo.log&lt;/file&gt;</span><br><span class="line">            &lt;encoder&gt;</span><br><span class="line">                &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt;</span><br><span class="line">            &lt;/encoder&gt;</span><br><span class="line">            &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;</span><br><span class="line">                &lt;fileNamePattern&gt;$&#123;log_dir&#125;/All/demo.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt;</span><br><span class="line">            &lt;/rollingPolicy&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/appender&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!--    &lt;/appender&gt;--&gt;</span><br><span class="line"></span><br><span class="line">    &lt;root level=&quot;DEBUG&quot;&gt;</span><br><span class="line">        &lt;appender-ref ref=&quot;STDOUT&quot;/&gt;</span><br><span class="line">        &lt;appender-ref ref=&quot;All_APPENDER&quot;&gt;&lt;/appender-ref&gt;</span><br><span class="line">        &lt;appender-ref ref=&quot;SERVICE_APPENDER&quot;/&gt;</span><br><span class="line">    &lt;/root&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &lt;logger name=&quot;org/example&quot; level=&quot;ERROR&quot; additivity=&quot;true&quot;&gt;</span><br><span class="line">            &lt;appender-ref ref=&quot;SERVICE_APPENDER&quot;/&gt;</span><br><span class="line">        &lt;/logger&gt;</span><br><span class="line"></span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><h3 id="官网文档阅读"><a href="#官网文档阅读" class="headerlink" title="官网文档阅读"></a>官网文档阅读</h3><p><a href="https://logback.qos.ch/manual/introduction.html">文档首页</a></p><p><a href="https://logback.qos.ch/setup.html">依赖导入说明</a></p><p>ps： 以下阅读并非纯粹的搬运、翻译，而是强调某些值得注意的地方。</p><h4 id="Chapter-1-Introduction"><a href="#Chapter-1-Introduction" class="headerlink" title="Chapter 1: Introduction"></a>Chapter 1: Introduction</h4><h5 id="1，logback内部状态打印"><a href="#1，logback内部状态打印" class="headerlink" title="1，logback内部状态打印"></a>1，logback内部状态打印</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import ch.qos.logback.classic.LoggerContext;  </span><br><span class="line">import ch.qos.logback.core.util.StatusPrinter2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">LoggerContext lc = (LoggerContext) LoggerFactory.getILoggerFactory();  </span><br><span class="line">new StatusPrinter2().print(lc);</span><br></pre></td></tr></table></figure><p>注意，上面使用的输出类为<code>StatusPrinter2()</code>,将打印logback上下文运状态，例如对配置文件的使用等，用于诊断logback的相关问题，且注意，</p><h4 id="Chapter-2-Architecture"><a href="#Chapter-2-Architecture" class="headerlink" title="Chapter 2: Architecture"></a>Chapter 2: Architecture</h4><h5 id="1，依赖架构"><a href="#1，依赖架构" class="headerlink" title="1，依赖架构"></a>1，依赖架构</h5><blockquote><p>[!NOTE] 官网描述<br>_核心_模块为其他两个模块奠定了基础。 <em>经典_模块扩展_了 core</em>。classic 模块对应于 log4j 的显著改进版本。Logback-classic 原生实现了 <a href="http://www.slf4j.org/">SLF4J API</a>，以便您可以轻松地在 logback 和其他日志记录系统之间来回切换，例如 JDK 1.4 中引入的 log4j 或 java.util.logging （JUL）。第三个模块称为 <em>access</em>，它与 Servlet 容器集成以提供 HTTP 访问日志功能。一个单独的文档涵盖了 <a href="https://logback.qos.ch/access.html">Access Module 文档</a> 。</p></blockquote><p>（1）Logback-classic 原生实现了 <a href="http://www.slf4j.org/">SLF4J API</a><br>这句话在api层面的表现为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import ch.qos.logback.classic.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line">Logger logger =(Logger) LoggerFactory.getLogger(&quot;chapters.introduction.HelloWorld1&quot;);  </span><br><span class="line">logger.debug(&quot;Hello world.&quot;);</span><br></pre></td></tr></table></figure><p>在<code>ch.qos.logback.classic.Logger</code>实现看到实现了<code>org.slf4j.Logger</code>这个接口，这就是代表他在扩展功能的同时，仍然支持原有的日志门面的功能，也就是<strong>在 logback 和其他日志记录系统之间来回切换</strong>。</p><h5 id="2，appender和layout"><a href="#2，appender和layout" class="headerlink" title="2，appender和layout"></a>2，appender和layout</h5><p>布局负责根据用户的意愿格式化日志记录请求，而 appender 负责将格式化的输出发送到其目的地。</p><p>默认配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h5 id="3，关于参数构造成本的优化"><a href="#3，关于参数构造成本的优化" class="headerlink" title="3，关于参数构造成本的优化"></a>3，关于参数构造成本的优化</h5><p><em>目前好像无论是slf4j,还是logback-classic的logger都支持参数传递</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">logger.debug(&quot;The new entry is &quot;+entry+&quot;.&quot;); </span><br><span class="line">logger.debug(&quot;The new entry is &#123;&#125;.&quot;, entry);</span><br></pre></td></tr></table></figure><p>第一种写法会先构造message造成额外浪费，而第二种会在真正需要打印debug日志时，才会拼接。</p><h5 id="4，info调用的关键节点"><a href="#4，info调用的关键节点" class="headerlink" title="4，info调用的关键节点"></a>4，info调用的关键节点</h5><ul><li>1， 获取过滤器链决策</li><li>2，应用基本选择规则</li><li>3, 创建 <code>LoggingEvent</code> 对象： 该对象包含要打印的各种数据，</li><li>4，从logger context中获取 appender，并执行（并非执行完成，而是进入下一步）</li><li>5， 格式化输出：部分需要将<code>LoggingEvent</code>委托给布局进行输出，部分不需要。<ul><li>该步骤貌似是格式化一个完整的日志事件，包含输出的目的地等</li></ul></li><li>6，发送 <code>LoggingEvent</code></li></ul><p>ps： 如何找到或者定义每个阶段？</p><h4 id="Chapter-3-Logback-configuration"><a href="#Chapter-3-Logback-configuration" class="headerlink" title="Chapter 3: Logback configuration"></a>Chapter 3: Logback configuration</h4><h5 id="1-Configurator"><a href="#1-Configurator" class="headerlink" title="1,Configurator"></a>1,Configurator</h5><p>全限定类名为：<code>import ch.qos.logback.classic.spi.Configurator;</code></p><p>默认实现有三个： </p><ul><li>BasicConfigurator： 最基本的默认实现，将输出指向控制台</li><li>DefaultJoranConfigurator： 依次寻找<code>logback-test.xml</code>、<code>logback.xml</code>。</li><li>SerializedModelConfigurator： 将于 2025 年 7 月 1 日从初始化序列中删除。</li></ul><p>自定义实现：</p><ul><li>实现<code>import ch.qos.logback.classic.spi.Configurator;</code></li><li>文件资源位于 <code>META-INF/services/ch.qos.logback.classic.spi.Configurator</code> ，内容是自定义类的全限定类名</li></ul><p>加载顺序： 只要找到一个实现就不会继续向下执行</p><ul><li>1，自定义</li><li>2，SerializedModelConfigurator</li><li>3，DefaultJoranConfigurator</li><li>4，BasicConfigurator</li></ul><h6 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h6><p>1，一个自定义的加载器应当具有以下格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class MyConfigurator  extends ContextAwareBase implements Configurator &#123;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    public ExecutionStatus configure(LoggerContext context) &#123;  </span><br><span class="line"></span><br><span class="line">1，加载配置文件</span><br><span class="line">ClassLoader myClassLoader= Loader.getClassLoaderOfObject(this);  </span><br><span class="line">  </span><br><span class="line">URL resource = getResource(configFile, myClassLoader);</span><br><span class="line"></span><br><span class="line">2，处理加载文件，并判断是否该加载器是否运行成功</span><br><span class="line">        if(resource==null)&#123;  </span><br><span class="line">            return  ExecutionStatus.INVOKE_NEXT_IF_ANY;  //寻找其他  </span><br><span class="line">        &#125;  </span><br><span class="line">        try &#123;  </span><br><span class="line">            configureByResource(resource);  </span><br><span class="line">        &#125; catch (JoranException e) &#123;  </span><br><span class="line">            throw new RuntimeException(e);  </span><br><span class="line">  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        addInfo(&quot;自定义配置: logback-spring.xml 加载成功，&quot;);  </span><br><span class="line">        return ExecutionStatus.DO_NOT_INVOKE_NEXT_IF_ANY;   //停止寻找其他  </span><br><span class="line">  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在以上自定义的过程中需要注意两点<br>1，适当的为上下文状态插入日志，也就是<code>ContextAwareBase</code>接口下实现的方法<br>2，ExecutionStatus菜单类的返回值，该返回值帮助调用者判断下一步该如何执行。</p><h5 id="2，上下文状态监听器"><a href="#2，上下文状态监听器" class="headerlink" title="2，上下文状态监听器"></a>2，上下文状态监听器</h5><ul><li>编码控制，动态添加： 由于无法获取添加之前的上下文状态，不去考虑</li><li>在配置文件使用使用标签<code>&lt;statusListener&gt;</code>指定<code>ch.qos.logback.core.status.StatusListener</code>的实现类<ul><li>可以自定义实现也可以使用官方的实现,且注意，该监听器并不能融入自定义的logger机制，他们只是对于上下文状态的日志监听！！</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">logback.xml</span><br><span class="line">&lt;configuration scan=&quot;true&quot; scanPeriod=&quot;60 seconds&quot; debug=&quot;false&quot;&gt;  </span><br><span class="line">  </span><br><span class="line">    &lt;property name=&quot;console&quot; value=&quot;==\n[%-5level] %red(%d&#123;HH:mm&#125;) Thread:[%thread]  Method:%green(%M) %cyan(%X&#123;traceId&#125;)   classpath:%c \n%highlight(return):%m%n&quot;&gt;&lt;/property&gt;  </span><br><span class="line">  </span><br><span class="line">    &lt;statusListener class=&quot;ch.qos.logback.core.status.OnConsoleStatusListener&quot; /&gt;  </span><br><span class="line">    &lt;statusListener class=&quot;ch.qos.logback.core.status.OnFileStatusListener&quot; /&gt;  </span><br><span class="line">  </span><br><span class="line">    &lt;root level=&quot;DEBUG&quot;&gt;  </span><br><span class="line">  </span><br><span class="line">        &lt;appender-ref ref=&quot;STDOUT&quot;&gt;&lt;/appender-ref&gt;  </span><br><span class="line">    &lt;/root&gt;  </span><br><span class="line">    &lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;  </span><br><span class="line">        &lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt;  </span><br><span class="line">            &lt;pattern&gt;$&#123;console&#125;&lt;/pattern&gt;  </span><br><span class="line">            &lt;charset&gt;utf8&lt;/charset&gt;  </span><br><span class="line">        &lt;/encoder&gt;    &lt;/appender&gt;&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><h5 id="3，停止classic"><a href="#3，停止classic" class="headerlink" title="3，停止classic"></a>3，停止classic</h5><blockquote><p>[!NOTE] Title<br>自1.1.10版本起，Logback-classic将自动请求Web服务器安装一个实现ServletContainerInitializer接口的LogbackServletContainerInitializer（在servlet-api 3.x及以后版本中可用）。这个初始化器反过来会安装一个LogbackServletContextListener的实例。当Web应用程序停止或重新加载时，这个监听器将停止当前的logback-classic上下文。</p></blockquote><p>具体实现上，则是通过<code>shutdown</code>钩子实现的，且在1.5.18版本上，只有一个钩子<code>ch.qos.logback.core.hook.</code></p><p><strong>这种关闭方式在底层的逻辑中关键语句为： loggerContext.stop();</strong>，即关闭整个logback，那么同样也就是关闭了classic。</p><p>混淆点： </p><ul><li>logbackContext并不是核心包的内容，或者说在真正使用中，单独的核心包并不能完成日志功能。<br>  <code>ch.qos.logback.classic.LoggerContext</code></li></ul><p>仔细排查之后发现，加载外部xml配置的Configurator都是classic的内容。</p><h5 id="xml配置语法"><a href="#xml配置语法" class="headerlink" title="xml配置语法"></a>xml配置语法</h5><p>![[Pasted image 20250514154750.png]]</p><p>ps： 有点长，等待阅读，给出一个我个人的控制台输出配置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;property name=&quot;console&quot; value=&quot;==\n[%-5level] %red(%d&#123;HH:mm&#125;) Thread:[%thread]  Method:%green(%M) %cyan(%X&#123;traceId&#125;)   classpath:%c \n%highlight(return):%m%n&quot;&gt;&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;  </span><br><span class="line">    &lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt;  </span><br><span class="line">        &lt;pattern&gt;$&#123;console&#125;&lt;/pattern&gt;  </span><br><span class="line">        &lt;charset&gt;utf8&lt;/charset&gt;  </span><br><span class="line">    &lt;/encoder&gt;&lt;/appender&gt;</span><br><span class="line">  </span><br><span class="line">&lt;root level=&quot;DEBUG&quot;&gt;  </span><br><span class="line">  </span><br><span class="line">    &lt;appender-ref ref=&quot;STDOUT&quot;&gt;&lt;/appender-ref&gt;  </span><br><span class="line">&lt;/root&gt;</span><br><span class="line"></span><br><span class="line">&lt;statusListener class=&quot;ch.qos.logback.core.status.OnConsoleStatusListener&quot; /&gt;  </span><br><span class="line">&lt;statusListener class=&quot;ch.qos.logback.core.status.OnFileStatusListener&quot; /&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;logback&quot;&gt;&lt;a href=&quot;#logback&quot; class=&quot;headerlink&quot; title=&quot;logback&quot;&gt;&lt;/a&gt;logback&lt;/h3&gt;&lt;h4 id=&quot;架构&quot;&gt;&lt;a href=&quot;#架构&quot; class=&quot;headerlink&quot; title=&quot;架</summary>
      
    
    
    
    
    <category term="源码阅读" scheme="http://wenzhuo4657.org/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>rocketmq源码阅读（一）：生产者初识</title>
    <link href="http://wenzhuo4657.org/2025/04/16/rocketmq%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%94%9F%E4%BA%A7%E8%80%85%E5%88%9D%E8%AF%86/"/>
    <id>http://wenzhuo4657.org/2025/04/16/rocketmq%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%94%9F%E4%BA%A7%E8%80%85%E5%88%9D%E8%AF%86/</id>
    <published>2025-04-16T11:28:54.000Z</published>
    <updated>2025-04-16T12:10:47.352Z</updated>
    
    <content type="html"><![CDATA[<h1 id="源码阅读（一）"><a href="#源码阅读（一）" class="headerlink" title="源码阅读（一）"></a>源码阅读（一）</h1><h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><p>rocketmq的java-sdk并没有什么特殊的构建的，直接加载maven即可。</p><p>节点部署：<br><a href="https://rocketmq.apache.org/zh/docs/quickStart/02quickstartWithDocker">Docker 部署 RocketMQ | RocketMQ</a></p><p>面板部署：<br><a href="https://github.com/apache/rocketmq-dashboard">apache&#x2F;rocketmq-dashboard</a></p><p>hhh，遵从官网部署，点点点就可以了。</p><h2 id="生产者初识"><a href="#生产者初识" class="headerlink" title="生产者初识"></a>生产者初识</h2><p>阅读源码首先要明确的目标，或者说我们想要了解什么？</p><p>在我看来生产者的职责分为以下几个</p><ul><li>1,与<code>namesrv</code>沟通，维护本地的<code>broker</code>通信队列</li><li>2,发送<code>topic</code>消息到远程<code>broker</code></li><li>3,根据响应结果判断是否发送成功，以及失败情况下的策略</li></ul><p>每一个生产者对于<code>broker</code>节点来说是消息的来源，但是<code>broker</code>并不关心究竟有多少个生产者在为它提供服务，对于消费者来说同样如此！</p><p>首先定位到源码示例</p><p><img src="/%5Bhttps:/blog.wenzhuo4657.org/img/2025/04/ce5a9ce6d095400e1dfefe77486c2729.png"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p><p>示例的逻辑并不复杂，但问题是怎么处理的？尝试追溯<code>DefaultMQProducer</code>,找到客户端的sdk模块<code>rocketmq-client</code></p><p>观察<code>DefaultMQProducer</code>的父类路径发现<code>extends ClientConfig implements MQProducer</code>,对于<code>MQProducer</code>没啥好说的，定义了生产者方法规范，而且没有注释。小白一只的我将目光对准<code>ClientConfig</code>,</p><p><code>private String clientIP = NetworkUtil.getLocalAddress();</code>  寻找ip的方法。</p><p><code>private String instanceName = System.getProperty(&quot;rocketmq.client.name&quot;, &quot;DEFAULT&quot;);</code>  生产者名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 客户端id，这个要注意与生产者名称区分，在我看来是类似与多元组一样的， ip+instanceName+......</span><br><span class="line">   </span><br><span class="line">public String buildMQClientId() &#123;</span><br><span class="line">    StringBuilder sb = new StringBuilder();</span><br><span class="line">    sb.append(this.getClientIP());</span><br><span class="line"></span><br><span class="line">    sb.append(&quot;@&quot;);</span><br><span class="line">    sb.append(this.getInstanceName());</span><br><span class="line">    if (!UtilAll.isBlank(this.unitName)) &#123;</span><br><span class="line">        sb.append(&quot;@&quot;);</span><br><span class="line">        sb.append(this.unitName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (enableStreamRequestType) &#123;</span><br><span class="line">        sb.append(&quot;@&quot;);</span><br><span class="line">        sb.append(RequestType.STREAM);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>需要注意的是对于修改<code>clentIP</code>可以直接通过<code>producer.setClientIP(DEFAULT_NAMESRVADDR);</code>,<code>clientID</code>则并没有这个字段，他是在生产者启动时自动生成的的一个标识符，或许可以这么说 <code>ip+instanceName</code>表示了这个主机上的所有rocketmq的消费者和生产者。</p><p>追溯<code>buildMQClientId</code>即可发现，start的调用链路中存在这个方法。</p><h3 id="与namesrv沟通，维护本地的broker通信队列"><a href="#与namesrv沟通，维护本地的broker通信队列" class="headerlink" title="与namesrv沟通，维护本地的broker通信队列"></a>与<code>namesrv</code>沟通，维护本地的<code>broker</code>通信队列</h3><p><code>DefaultMQProducer#start() -&gt; DefaultMQProducerImpl#start() -&gt; MQClientManager.getInstance().getOrCreateMQClientInstance(this.defaultMQProducer, rpcHoo)  -&gt; MQClientInstance # new MQClientInstance(ClientConfig clientConfig, int instanceIndex, String clientId, RPCHook rpcHook)</code></p><p>追溯到<code>MQClientInstance</code>的初始化，在这里类中可以看到非常重要的几个属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## broker节点列表 ket为id,value为 ip地址</span><br><span class="line">private final ConcurrentMap&lt;String, HashMap&lt;Long, String&gt;&gt; brokerAddrTable = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">## 心跳检查开关，源码中显示用于管理broker节点的连接是否实效</span><br><span class="line">private boolean enableHeartbeatChannelEventListener = true;</span><br><span class="line"></span><br><span class="line">##  消费者状态代理</span><br><span class="line">this.consumerStatsManager</span><br><span class="line"></span><br><span class="line">##  netty连接客户端配置</span><br><span class="line">private final NettyClientConfig nettyClientConfig;</span><br></pre></td></tr></table></figure><p>断点查看参数后发现<code>new MQClientInstance(ClientConfig clientConfig, int instanceIndex, String clientId, RPCHook rpcHook)</code>初始化的是远程namesrv的客户端。<br>![[Pasted image 20250409182100.png]]</p><h4 id="namesrv的配置"><a href="#namesrv的配置" class="headerlink" title="namesrv的配置"></a>namesrv的配置</h4><p>结论： 存在不一致则直接覆盖更新，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">NettyRemotingClient&#123;</span><br><span class="line">private final AtomicReference&lt;List&lt;String&gt;&gt; namesrvAddrList = new AtomicReference&lt;&gt;();//这个原子引用在方法中充当了互斥锁</span><br><span class="line"></span><br><span class="line"> public void updateNameServerAddressList(List&lt;String&gt; addrs) &#123;  </span><br><span class="line">        List&lt;String&gt; old = this.namesrvAddrList.get();  </span><br><span class="line">        boolean update = false;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">//        1,如果存在不一致，则全部更新  </span><br><span class="line">        if (!addrs.isEmpty()) &#123;  </span><br><span class="line">            if (null == old) &#123;//olg不存在  </span><br><span class="line">                update = true;  </span><br><span class="line">            &#125; else if (addrs.size() != old.size()) &#123;//数量不一致  </span><br><span class="line">                update = true;  </span><br><span class="line">            &#125; else &#123;  </span><br><span class="line">                for (String addr : addrs) &#123;  </span><br><span class="line">                    if (!old.contains(addr)) &#123;//存在差异  </span><br><span class="line">                        update = true;  </span><br><span class="line">                        break;                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">            if (update) &#123;  </span><br><span class="line">            this.namesrvAddrList.set(addrs);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处引申出两个新问题,<br>1,如何复用<code>MQClientInstance </code>?<br>调用链路中直接上级是<br><code>MQClientManager</code>,关键成员变量为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private ConcurrentMap&lt;String/* clientId */, MQClientInstance&gt; factoryTable =</span><br><span class="line">    new ConcurrentHashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><p>2,<code>namesrv</code>存在更新，看上去是MQClientInstance 重新初始化的缘故？那么为什么会重新初始化？<code>namesrv</code>应当写死在配置文件当中，但此处似乎允许动态更新？</p><p>追溯<code>ClientConfig</code>信息的来源发现在<code>DefaultMQProducerImpl</code>成员变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    private final DefaultMQProducer defaultMQProducer;</span><br><span class="line">public class DefaultMQProducer extends ClientConfig implements MQProducer &#123;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从接口角度上来说，DefaultMQProducer确实是生产者实现，但可以将<code>DefaultMQProducerImpl</code>理解为生产者的启动类，而并非实现类。</p><p>此外这个实现类会默认使用环境变量（或者是其他配置），然后使用编码角度的上层配置覆盖，这也是常规的编码&gt;环境变量的实现。</p><h4 id="维护broker队列"><a href="#维护broker队列" class="headerlink" title="维护broker队列"></a>维护broker队列</h4><p>追溯发送消息的方法找到关键方法<code>sendKernelImpl</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class DefaultMQProducerImpl&#123;</span><br><span class="line"> private SendResult sendKernelImpl(。。。 ) &#123;</span><br><span class="line">        </span><br><span class="line">String brokerName = this.mQClientFactory.getBrokerNameFromMessageQueue(mq);</span><br><span class="line">String brokerAddr = this.mQClientFactory.findBrokerAddressInPublish(brokerName);</span><br><span class="line"></span><br><span class="line">        if (null == brokerAddr) &#123;</span><br><span class="line">            tryToFindTopicPublishInfo(mq.getTopic());</span><br><span class="line">            brokerName = this.mQClientFactory.getBrokerNameFromMessageQueue(mq);</span><br><span class="line">            brokerAddr = this.mQClientFactory.findBrokerAddressInPublish(brokerName);</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1,获取brokerAddr地址时并不会检验是否有效，只要有对应缓存即可<br>2,<code> tryToFindTopicPublishInfo(mq.getTopic());</code> 会在本地没有对应topic条目时更新</p><p>基于以上两点可以看出，默认实现里对于broker的维护似乎是通过发送消息错误时重新拉取实现的？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DefaultMQProducerImpl#sendKernelImpl  -》</span><br><span class="line">this.mQClientFactory.getMQClientAPIImpl().sendMessage   -》</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在<code>sendmessgae</code>中发送消息有三种走向，通过<code>switch</code>区分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">switch (communicationMode) &#123;</span><br><span class="line">         case ONEWAY:  //单向发送</span><br><span class="line">             this.remotingClient.invokeOneway(addr, request, timeoutMillis);</span><br><span class="line"></span><br><span class="line">         case ASYNC:  //异步发送</span><br><span class="line">         </span><br><span class="line">             this.sendMessageAsync(addr, brokerName, msg, timeoutMillis - costTimeAsync, request, sendCallback, topicPublishInfo, instance,</span><br><span class="line">                 retryTimesWhenSendFailed, times, context, producer);</span><br><span class="line"> </span><br><span class="line">         case SYNC:   //同步发送</span><br><span class="line">         </span><br><span class="line">             return this.sendMessageSync(addr, brokerName, msg, timeoutMillis - costTimeSync, request);</span><br><span class="line">         default:</span><br><span class="line">             assert false;</span><br><span class="line">             break;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>单向发送： 不会判断是否发送成功<br>异步发送&#x2F;同步发送：会根据ack或者响应超时等其他指标判断消息是否发送成功</p><p>因此需要注意，假设使用了单向发送，那么先前的推论<code>根据相应判断broker是否有效</code>就不成立，或者说不会单单根据这个判断broker是否有效。</p><h5 id="心跳模式"><a href="#心跳模式" class="headerlink" title="心跳模式"></a>心跳模式</h5><p>重新阅读源码，追溯<code>brokerAddrTable</code>调用发现心跳模式，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">if (clientConfig.isEnableHeartbeatChannelEventListener()) &#123;</span><br><span class="line">           channelEventListener = new ChannelEventListener() &#123;</span><br><span class="line">               </span><br><span class="line">               private final ConcurrentMap&lt;String, HashMap&lt;Long, String&gt;&gt; brokerAddrTable = MQClientInstance.this.brokerAddrTable;</span><br><span class="line"></span><br><span class="line">               @Override</span><br><span class="line">               public void onChannelActive(String remoteAddr, Channel channel) &#123;</span><br><span class="line">                   for (Map.Entry&lt;String, HashMap&lt;Long, String&gt;&gt; addressEntry : brokerAddrTable.entrySet()) &#123;</span><br><span class="line">                       for (Map.Entry&lt;Long, String&gt; entry : addressEntry.getValue().entrySet()) &#123;</span><br><span class="line">                           String addr = entry.getValue();</span><br><span class="line">                           if (addr.equals(remoteAddr)) &#123;</span><br><span class="line">                               long id = entry.getKey();</span><br><span class="line">                               String brokerName = addressEntry.getKey();</span><br><span class="line">                               if (sendHeartbeatToBroker(id, brokerName, addr, false)) &#123;</span><br><span class="line">                                   rebalanceImmediately();</span><br><span class="line">                               &#125;</span><br><span class="line">                               break;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure><p>核心判断<code> if (addr.equals(remoteAddr)) &#123;。。。  break;&#125;</code>  </p><p>结合心跳模式的判断，<br>1,此处应当为borker地址的监听判断，或者说维护。<br>2,这里仍然不是拉去broker的地址</p><h5 id="定时任务：-清除离线broker"><a href="#定时任务：-清除离线broker" class="headerlink" title="定时任务： 清除离线broker"></a>定时任务： 清除离线broker</h5><p>再一次追溯调用找到定时任务，每秒执行一次</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MQClientInstance#startScheduledTask</span><br><span class="line">this.scheduledExecutorService.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                MQClientInstance.this.cleanOfflineBroker();</span><br><span class="line">                MQClientInstance.this.sendHeartbeatToAllBrokerWithLock();</span><br><span class="line">            &#125; catch (Throwable t) &#123;</span><br><span class="line">                log.error(&quot;ScheduledTask sendHeartbeatToAllBroker exception&quot;, t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, 1000, this.clientConfig.getHeartbeatBrokerInterval(), TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MQClientInstance.this.cleanOfflineBroker();  -》</span><br><span class="line">this.isBrokerAddrExistInTopicRouteTable(addr)</span><br></pre></td></tr></table></figure><p>该方法内部依赖<code>TopicRouteData</code>的维护，并且仅仅判断是否存在对应的<code>broker</code>地址，而不关心是否有对应topic</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private boolean isBrokerAddrExistInTopicRouteTable(final String addr) &#123;</span><br><span class="line">       for (Entry&lt;String, TopicRouteData&gt; entry : this.topicRouteTable.entrySet()) &#123;</span><br><span class="line">           TopicRouteData topicRouteData = entry.getValue();</span><br><span class="line">           List&lt;BrokerData&gt; bds = topicRouteData.getBrokerDatas();</span><br><span class="line">           for (BrokerData bd : bds) &#123;</span><br><span class="line">               if (bd.getBrokerAddrs() != null) &#123;</span><br><span class="line">                   boolean exist = bd.getBrokerAddrs().containsValue(addr);</span><br><span class="line">                   if (exist)</span><br><span class="line">                       return true;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>根据方法的注释，可以判断<code>TopicRouteData</code>的数据是需要作为依据存在，准确性要比<code>brokerAddrTable</code> 高。</p><h5 id="updateTopicRouteInfoFromNameServer"><a href="#updateTopicRouteInfoFromNameServer" class="headerlink" title="updateTopicRouteInfoFromNameServer"></a>updateTopicRouteInfoFromNameServer</h5><p>更新路由拉区信息，无同步</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（final String topic, boolean isDefault,</span><br><span class="line">        DefaultMQProducer defaultMQProducer)</span><br></pre></td></tr></table></figure><p>因此该方法用于更新指定生产者下的topic的地址，</p><p>调用时机： </p><ul><li>1, sendKernelImpl下没有topic对应的<code>MASTER_ID</code>的节点时。</li><li></li></ul><p>阅读源码发现，生产者作用似乎仅仅是指定了队列数量，但是其他数量都使用了当前MQClientInstance实例的数据，那么就引申出一个新问题，就是生产者和实例的对应关系？MQClientInstance似乎可以复用，在前面的方法调用当中存在<code>getOrCreateMQClientInstance</code>，仅仅从方法名称中也可以发现似乎存在某个变量维护着一个公共的&#96;MQClientInstance&#96;&#96;？</p><h5 id="MQClientManager和MQClientInstance"><a href="#MQClientManager和MQClientInstance" class="headerlink" title="MQClientManager和MQClientInstance"></a>MQClientManager和MQClientInstance</h5><p>首先说结论，这两对象都是能复用就复用，不会做额外的判断。</p><p>MQClientManager在调用时，直接使用的是静态成员变量<br><code>   private static MQClientManager instance = new MQClientManager();</code></p><p>MQClientInstance通过上面的静态成员变量维护了一个成员变量，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private ConcurrentMap&lt;String/* clientId */, MQClientInstance&gt; factoryTable =</span><br><span class="line">     new ConcurrentHashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><p>回顾clientiD的创建方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public String buildMQClientId() &#123;</span><br><span class="line">    StringBuilder sb = new StringBuilder();</span><br><span class="line">    sb.append(this.getClientIP());</span><br><span class="line"></span><br><span class="line">    sb.append(&quot;@&quot;);</span><br><span class="line">    sb.append(this.getInstanceName());</span><br><span class="line">    if (!UtilAll.isBlank(this.unitName)) &#123;</span><br><span class="line">        sb.append(&quot;@&quot;);</span><br><span class="line">        sb.append(this.unitName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (enableStreamRequestType) &#123;</span><br><span class="line">        sb.append(&quot;@&quot;);</span><br><span class="line">        sb.append(RequestType.STREAM);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>四元组为： ip： 实例名称: 单元名称： 流式请求</p><p>尝试使用相同clientId后成功启动。</p><h5 id="TopicRouteInfo"><a href="#TopicRouteInfo" class="headerlink" title="TopicRouteInfo"></a>TopicRouteInfo</h5><p>目前来讲brokerAddrTable有只有一个直接来源<code>topicRouteTable</code></p><p>追溯调用找到关键方法<code>MQClientInstance#updateTopicRouteInfoFromNameServer</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public boolean updateTopicRouteInfoFromNameServer(，，，）&#123;</span><br><span class="line"> topicRouteData = this.mQClientAPIImpl.getDefaultTopicRouteInfoFromNameServer(clientConfig.getMqClientApiTimeout());</span><br><span class="line"> // 中间省略的操作大致作用为old、young合并</span><br><span class="line">this.topicRouteTable.put(topic, cloneTopicRouteData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">追溯找到路由信息的请求定义</span><br><span class="line">InterruptedException, RemotingTimeoutException, RemotingSendRequestException, RemotingConnectException &#123;  </span><br><span class="line">    GetRouteInfoRequestHeader requestHeader = new GetRouteInfoRequestHeader();  </span><br><span class="line">    requestHeader.setTopic(topic);  </span><br><span class="line">    RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.GET_ROUTEINFO_BY_TOPIC, requestHeader);</span><br></pre></td></tr></table></figure><p>注意核心请求code</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RequestCode.GET_ROUTEINFO_BY_TOPIC,</span><br><span class="line"></span><br><span class="line">public static final int GET_ROUTEINFO_BY_TOPIC = 105;</span><br></pre></td></tr></table></figure><h5 id="发送消息失败"><a href="#发送消息失败" class="headerlink" title="发送消息失败"></a>发送消息失败</h5><p>发送消息失败，会抛出自定义错误<code>RemotingException e</code> 交给<code>DefaultMQProducerImpl#sendDefaultImpl</code>的catch处理，断点查看得知，在默认情况下，会尝试隔离broker</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#125; catch (RemotingException e) &#123;  </span><br><span class="line">    endTimestamp = System.currentTimeMillis();  </span><br><span class="line">    if (this.mqFaultStrategy.isStartDetectorEnable()) &#123;  </span><br><span class="line">        // Set this broker unreachable when detecting schedule task is running for RemotingException.  </span><br><span class="line">        this.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, true, false);  </span><br><span class="line">    &#125; else &#123;  </span><br><span class="line">        // Otherwise, isolate this broker.  </span><br><span class="line">        在内部方法的调用链路中，发现他会重新检测broker的状态，</span><br><span class="line">        this.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, true, true);  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>生产者网络通信： <code>remotingClient</code><br>生产者通信api封装： <code>MQClientAPIImpl</code><br>生产者动态信息保存： <code>MQClientInstance</code><br>生产者动态信息- 经理：<code>MQClientManager</code><br>默认生产者实现：<code>DefaultMQProducerImpl</code><br>默认生产者的定义： <code>DefaultMQProducer</code></p><p>初始化<code>remotingClient</code>会以当前编码配置为主。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//        1,如果存在不一致，则全部更新  </span><br><span class="line">        if (!addrs.isEmpty()) &#123;  </span><br><span class="line">            if (null == old) &#123;//olg不存在  </span><br><span class="line">                update = true;  </span><br><span class="line">            &#125; else if (addrs.size() != old.size()) &#123;//数量不一致  </span><br><span class="line">                update = true;  </span><br><span class="line">            &#125; else &#123;  </span><br><span class="line">                for (String addr : addrs) &#123;  </span><br><span class="line">                    if (!old.contains(addr)) &#123;//存在差异  </span><br><span class="line">                        update = true;  </span><br><span class="line">                        break;                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>broker的更新和维护</p><p>1,心跳模式<br>2,定时任务根据路由信息更新<br>3,不存在对应的topic信息时，会发送code为105的请求到namesrv中<br>4,默认情况下，发送消息失败会尝试隔离对应的broker</p><p><img src="https://blog.wenzhuo4657.org/img/2025/04/20244c5203f9570357a426db7ebc3a23.png"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p><p>客户端所用的code类<br><code>org.apache.rocketmq.remoting.protocol.RequestCode</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;源码阅读（一）&quot;&gt;&lt;a href=&quot;#源码阅读（一）&quot; class=&quot;headerlink&quot; title=&quot;源码阅读（一）&quot;&gt;&lt;/a&gt;源码阅读（一）&lt;/h1&gt;&lt;h2 id=&quot;搭建环境&quot;&gt;&lt;a href=&quot;#搭建环境&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="源码" scheme="http://wenzhuo4657.org/categories/%E6%BA%90%E7%A0%81/"/>
    
    
  </entry>
  
  <entry>
    <title>maven插件新手解惑</title>
    <link href="http://wenzhuo4657.org/2025/04/06/maven%E6%8F%92%E4%BB%B6%E6%96%B0%E6%89%8B%E8%A7%A3%E6%83%91/"/>
    <id>http://wenzhuo4657.org/2025/04/06/maven%E6%8F%92%E4%BB%B6%E6%96%B0%E6%89%8B%E8%A7%A3%E6%83%91/</id>
    <published>2025-04-06T08:44:01.000Z</published>
    <updated>2025-04-06T12:22:46.063Z</updated>
    
    <content type="html"><![CDATA[<h2 id="maven插件的定义"><a href="#maven插件的定义" class="headerlink" title="maven插件的定义"></a>maven插件的定义</h2><p>maven插件的定义是在pom文件下的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugins&gt;</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">2.6</span><span class="number">.0</span>&lt;/version&gt;   </span><br><span class="line">     &lt;/plugin&gt;</span><br><span class="line"> &lt;/plugins&gt;</span><br></pre></td></tr></table></figure><p>与常规的依赖定位一致，而插件的配置则是在<executions>、<configuration>等标签下定义的，他们或许是环境变量或许是在maven生命周期的插入点。</p><p>简单来说maven插件的两个用途</p><p>1,融入maven生命周期，增加外挂式的功能</p><p>2,不参入maven生周期，直接使用（例如，在微服务领域下，将服务的定义IDL文件编译为特定语言的接口文件。）</p><h2 id="maven插件的原理"><a href="#maven插件的原理" class="headerlink" title="maven插件的原理"></a>maven插件的原理</h2><p><strong>Maven 是一个意第绪语单词，意为 知识的积累者，最初是为了简化 Jakarta Turbine 项目的构建过程而创建的。当时有多个项目，每个项目都有自己的 Ant 构建文件，而且每个文件都略有不同。JAR 被签入 CVS。我们希望有一种标准的方法来构建项目，明确定义项目包含的内容，一种发布项目信息的简便方法，以及一种在多个项目之间共享 JAR 的方法。</strong></p><p>这段话取自<a href="https://maven.apache.org/what-is-maven.html">官网</a>对于maven的定义,可以看出maven的核心在于管理jar文件，便于多个不同的项目去引入相同的jar。</p><p><strong>“Maven” 实际上只是一组 Maven 插件的核心框架。换句话说，插件是执行大部分实际操作的地方，插件用于：创建 jar 文件、创建 war 文件、编译代码、单元测试代码、创建项目文档等等。您能想到的在项目上执行的几乎所有操作都是作为 Maven 插件实现的。</strong></p><p>这段话取自<a href="https://maven.apache.org/guides/introduction/introduction-to-plugins.html">插件开发简介</a>,也就是说maven的插件的目标是生命周期，而生命周期在官方术语中被称为<code>Mojo</code>.</p><p>进而去查看maven插件开发的示例即可发现，插件实际上就是依托与maven这个框架所提供的扩展点所构建出来的可执行jar文件。</p><p>至此对于maven插件的和依赖的之间的关系就已经很明确了，他们实际上是一样，都可以作为依赖去使用，实际上更准确的说法是，可以融入maven生命周期的依赖被称为maven插件。</p><p><em>如果想要学习maven插件开发，就一定要仔细查看maven的<a href="https://maven.apache.org/plugin-developers/index.html">官方文档</a></em></p><h2 id="maven插件示例解读"><a href="#maven插件示例解读" class="headerlink" title="maven插件示例解读"></a>maven插件示例解读</h2><h3 id="spring-boot-maven-plugin"><a href="#spring-boot-maven-plugin" class="headerlink" title="spring-boot-maven-plugin"></a>spring-boot-maven-plugin</h3><h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><p>什么是springboot?通常我们说springboot是对于各种依赖自动配置的boot工具，便于快速开发，避免依赖的困扰，这种方式目前已经不止是springboot的独有，只是它依托与spring生态最为出名而已。</p><p>springboot与spring最大的区别在我这个小白看来则是注解开发，@SpringBootApplication定义程序的启动入口，所有的程序都需要依托于这个主类进行加载，而传统的spring项目则需要依托与web容器启动servlet配置，也就WebApplicationInitializer（简单来说是用于将项目中所有的servlet加载到web容器当中，参如http请求当中的rest控制器部分）。</p><p>无论如何我们需要明白一个jar包的执行是需要一个入口！而不同项目的入口是不一样！</p><p>对于普通jar包来说，他只需要将当前项目的class文件打包即可，而一个可执行的jar包则额外的需要依赖、入口、引导器。（如果稍微了解一点jvm知识就应该明白，java程序并不会在加载阶段去校验import是否存在，至于执行更是需要一个明确的入口。）</p><p>可执行jar:  </p><ul><li>将依赖引入jar包当中</li><li>META-INF&#x2F;MANIFEST.MF文件中存在启动类等配置</li><li>使用命令<code>java -jar</code> 执行</li></ul><p>不可执行jar:</p><ul><li>内部只有项目的class文件</li><li>META-INF&#x2F;MANIFEST.MF文件中不存在启动类等配置</li><li>不能使用<code>java -jar</code> 执行。</li></ul><p>java -jar执行逻辑： JVM会根据MANIFEST.MF文件中的Main-Class属性找到程序的入口点（即主类），然后开始执行该类的main方法</p><p>注意： 我找不到2.6的文档，凑和看<a href="https://docs.spring.io/spring-boot/maven-plugin/getting-started.html">spring官方文档</a>的最新版本解说。</p><h4 id="spring-boot-maven-plugin-repackage"><a href="#spring-boot-maven-plugin-repackage" class="headerlink" title="spring-boot-maven-plugin:repackage"></a>spring-boot-maven-plugin:repackage</h4><p><em>该repackage目标不应在命令行上单独使用，因为它会对 阶段生成的源jar（或）进行操作</em></p><p>翻译成人话就是他需要在maven生命周期的打包阶段之后执行，并且无法单独执行，只能绑定在该打包阶段伴随执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">           &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.6.0&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">                &lt;executions&gt;</span><br><span class="line">&lt;!--                    每一个&lt;execution&gt;都是一个归档包的定义 --&gt;</span><br><span class="line">&lt;!--                    可执行jar包配置--&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;id&gt;repackage&lt;/id&gt;</span><br><span class="line">                        &lt;goals&gt;</span><br><span class="line">&lt;!--                            绑定生命周期在package后--&gt;</span><br><span class="line">                            &lt;goal&gt;repackage&lt;/goal&gt;</span><br><span class="line">                        &lt;/goals&gt;</span><br><span class="line">                        &lt;configuration&gt;</span><br><span class="line">&lt;!--                            为可执行jar包新增后缀名，避免和普通jar包冲突--&gt;</span><br><span class="line">                            &lt;classifier&gt;exec&lt;/classifier&gt;</span><br><span class="line">                        &lt;/configuration&gt;</span><br><span class="line">                    &lt;/execution&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br></pre></td></tr></table></figure><p>classifier: 分类器。官网的解释很绕口，总之实现结果就是给重新打包的jar增加后缀，否则，就会替换普通jar，普通jar最终也只会在构建的target中出现。</p><p>该配置定义了一个将普通jar包重新打包、新增后缀exec的可执行jar包，且需要注意的是，他并不能影响原有的生命周期，具体来说则是maven仓库中依赖的存储，在仓库中依旧只有原本的普通jar的路径，无法将这个新增的jar引入其他项目当中。</p><p>如果我们想要引入可执行的jar包（无论处何种目的，总之如果有这种需求的话）</p><p>attach：将要安装到本地 Maven 存储库或部署到远程存储库的重新打包的存档附加到其中。如果未配置分类器，它将替换普通 jar。如果classifier已配置，使得普通 jar 和重新打包的 jar 不同，它将与普通 jar 一起附加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">       &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.6.0&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">                &lt;executions&gt;</span><br><span class="line">&lt;!--                    每一个&lt;execution&gt;都是一个归档包的定义 --&gt;</span><br><span class="line">&lt;!--                    可执行jar包配置--&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;id&gt;repackage&lt;/id&gt;</span><br><span class="line">                        &lt;goals&gt;</span><br><span class="line">&lt;!--                            绑定生命周期在package后--&gt;</span><br><span class="line">                            &lt;goal&gt;repackage&lt;/goal&gt;</span><br><span class="line">                        &lt;/goals&gt;</span><br><span class="line">                        &lt;configuration&gt;</span><br><span class="line">      </span><br><span class="line">                 &lt;attach&gt;true&lt;/attach&gt;</span><br><span class="line">                        &lt;/configuration&gt;</span><br><span class="line">                    &lt;/execution&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">       </span><br></pre></td></tr></table></figure><p>这样配置之后，在仓库中存在的就是可执行的jar。而普通jar只会在target构建目录中出现。</p><h4 id="spring-boot-maven-plugin-build-image"><a href="#spring-boot-maven-plugin-build-image" class="headerlink" title="spring-boot-maven-plugin:build-image"></a>spring-boot-maven-plugin:build-image</h4><p>构建镜像用的，默认使用本地docker,远程docker要配置额外的东西，总之很麻烦，只在本地尝试了以下。</p><h4 id="spring-boot-maven-plugin-help"><a href="#spring-boot-maven-plugin-help" class="headerlink" title="spring-boot-maven-plugin:help"></a>spring-boot-maven-plugin:help</h4><p>插件各个功能的简单介绍。</p><p>除此之外还有一些，新版插件新增了aot提前编译功能，有机会可以自行尝试。</p><h2 id="maven官方插件与非官方插件"><a href="#maven官方插件与非官方插件" class="headerlink" title="maven官方插件与非官方插件"></a>maven官方插件与非官方插件</h2><p>官方：maven-${prefix}-plugin<br>第三方：${prefix}-maven-plugin</p><p>官方可用插件：<a href="https://maven.apache.org/plugins/index.html">Available Plugins – Maven</a><br>非官方可用插件：<a href="https://github.com/mojohaus">MojoHaus · GitHub</a></p><p>参考文档：</p><p><a href="https://www.spring-doc.cn/spring-boot/3.4.0/maven-plugin_packaging.html">打包可执行存档文件 (Packaging Executable Archives) | Spring Boot3.4.0中文文档|Spring官方文档|SpringBoot 教程|Spring中文网</a></p><p><a href="https://blog.csdn.net/weixin_45760137/article/details/118725697">Spring Boot 打包成的 jar 和普通jar有什么区别_spring boot 打成的 jar 和普通的 jar 有什么区别-CSDN博客</a></p><p><a href="https://juejin.cn/post/7055598592999817253">Maven-插件使用与配置什么是插件 插件可以理解为一组任务的集合，用户可以通过命令行直接运行指定插件的任务，也可以将插 - 掘金</a></p><p><a href="https://maven.apache.org/guides/introduction/introduction-to-plugins.html">https://maven.apache.org/guides/introduction/introduction-to-plugins.html</a></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>插件这东西吧，最开始总是搞不懂，一直都是复制粘贴别人的配置，经过这次学习，倒不是说技术成长了多少，哈哈，其实甚至没有技术，只是看文档尝试功能而已。</p><p>没错，就是看文档，一定学会看官方文档！！！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;maven插件的定义&quot;&gt;&lt;a href=&quot;#maven插件的定义&quot; class=&quot;headerlink&quot; title=&quot;maven插件的定义&quot;&gt;&lt;/a&gt;maven插件的定义&lt;/h2&gt;&lt;p&gt;maven插件的定义是在pom文件下的&lt;/p&gt;
&lt;figure class=</summary>
      
    
    
    
    <category term="教程" scheme="http://wenzhuo4657.org/categories/%E6%95%99%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>关于@RequestParam的常见误区</title>
    <link href="http://wenzhuo4657.org/2025/03/29/%E5%85%B3%E4%BA%8E-RequestParam%E7%9A%84%E5%B8%B8%E8%A7%81%E8%AF%AF%E5%8C%BA/"/>
    <id>http://wenzhuo4657.org/2025/03/29/%E5%85%B3%E4%BA%8E-RequestParam%E7%9A%84%E5%B8%B8%E8%A7%81%E8%AF%AF%E5%8C%BA/</id>
    <published>2025-03-29T07:35:29.000Z</published>
    <updated>2025-04-06T06:23:27.297Z</updated>
    
    <content type="html"><![CDATA[<p>首先说结论，@RequestParam不仅可以结束queryString的参数，还可以接收表单数据。</p><h2 id="关于http载荷的区分"><a href="#关于http载荷的区分" class="headerlink" title="关于http载荷的区分"></a>关于http载荷的区分</h2><ul><li><p>queryString</p><p><code>http://example.com/path?key1=value1&amp;key2=value2&amp;key3=value3</code></p><p>无论是get还是post，他在url上的表现都是上述，而关于get和post的区别主要显示在http报文上字段填充。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /search?q=springboot&amp;page=1 HTTP/1.1</span><br><span class="line">Host: example.com</span><br><span class="line">Accept: application/json</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">路径和请求体可以共存，但是他们都统一可以使用作为queryString参数进行键值对解析。</span><br><span class="line">POST /submit?id=123 HTTP/1.1</span><br><span class="line">Host: example.com</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;&quot;name&quot;: &quot;Alice&quot;&#125;</span><br></pre></td></tr></table></figure></li></ul><p>事实上，queryStirng参数的核心在于键值，而不是位于请求体、路径。</p><ul><li><p>multipart&#x2F;form-data</p><p>文件上传</p></li><li><p>application&#x2F;x-www-form-urlencoded</p><p>表单文件</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;首先说结论，@RequestParam不仅可以结束queryString的参数，还可以接收表单数据。&lt;/p&gt;
&lt;h2 id=&quot;关于http载荷的区分&quot;&gt;&lt;a href=&quot;#关于http载荷的区分&quot; class=&quot;headerlink&quot; title=&quot;关于http载荷的区分&quot;</summary>
      
    
    
    
    <category term="springboot" scheme="http://wenzhuo4657.org/categories/springboot/"/>
    
    
  </entry>
  
  <entry>
    <title>八大排序算法梳理</title>
    <link href="http://wenzhuo4657.org/2025/03/18/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%A2%B3%E7%90%86/"/>
    <id>http://wenzhuo4657.org/2025/03/18/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%A2%B3%E7%90%86/</id>
    <published>2025-03-18T01:42:18.000Z</published>
    <updated>2025-04-06T06:23:27.297Z</updated>
    
    <content type="html"><![CDATA[<p>本篇blog的语言为java实现，介意请划走</p><h1 id="八大排序算法"><a href="#八大排序算法" class="headerlink" title="八大排序算法"></a>八大排序算法</h1><ul><li>冒泡排序</li><li>选择排序</li><li>插入排序</li><li>希尔排序</li><li>快速排序</li><li>归并排序</li><li>桶排序</li><li>堆排序</li></ul><p>上述排序值得注意的是堆排序，他利用顺序二叉树实现了对堆元素的随机存取，而他所操作的虽然是数组结构，但本质上我们将其视为一个二叉树。</p><h2 id="基本排序算法（并不复杂，甚至称不上算法，理解即可）"><a href="#基本排序算法（并不复杂，甚至称不上算法，理解即可）" class="headerlink" title="基本排序算法（并不复杂，甚至称不上算法，理解即可）"></a>基本排序算法（并不复杂，甚至称不上算法，理解即可）</h2><h3 id="冒泡"><a href="#冒泡" class="headerlink" title="冒泡"></a>冒泡</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubble_sort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="type">int</span> i, j, temp, len = arr.length;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++)</span><br><span class="line"><span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">temp = arr[j];</span><br><span class="line">arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>时间复杂度（n^2）</p><p>每次排序将最大值放入末尾，且注意，该算法的核心在于逐步排序，内层循环将较小或者较大的值下沉。</p><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>在冒泡排序中，我们逐步将最大或最小值后移，而选择排序优化了这个过程，比较过程并不移动数组元素，而是先找到将要移动的坐标。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: 选择排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> JourWon</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/7/11 23:31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selectionSort</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (array == <span class="literal">null</span> || array.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> array.length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="comment">// 保存最小数的索引</span></span><br><span class="line"><span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; length; j++) &#123;</span><br><span class="line"><span class="comment">// 找到最小的数</span></span><br><span class="line"><span class="keyword">if</span> (array[j] &lt; array[minIndex]) &#123;</span><br><span class="line">minIndex = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换元素位置</span></span><br><span class="line"><span class="keyword">if</span> (i != minIndex) &#123;</span><br><span class="line">swap(array, minIndex, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: 交换元素位置</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> b</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> JourWon</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/7/11 17:57</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> array[a];</span><br><span class="line">array[a] = array[b];</span><br><span class="line">array[b] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>该思想和动态规划有点像，即我们假定要将插入某个元素插入一个有序数组，那么我们只需要从数组起点或者某位逐步比较即可。</p><p>注意：<strong>数组元素的比较必须满足a&gt;&#x3D;b,b&gt;&#x3D;c,一定能推出a&gt;&#x3D;c。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 插入排序 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">insertionSort</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="comment">// 外循环：已排序区间为 [0, i-1]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">base</span> <span class="operator">=</span> nums[i], j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 内循环：将 base 插入到已排序区间 [0, i-1] 中的正确位置</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &gt; base) &#123;</span><br><span class="line">            nums[j + <span class="number">1</span>] = nums[j]; <span class="comment">// 将 nums[j] 向右移动一位</span></span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[j + <span class="number">1</span>] = base;        <span class="comment">// 将 base 赋值到正确位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="较为复杂的排序"><a href="#较为复杂的排序" class="headerlink" title="较为复杂的排序"></a>较为复杂的排序</h2><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>核心思想：通过步长指定分组，将每次分组内的数据变得有序。这样当我们减少步长时，虽然数组元素并不会因此有序，但是会变得相对容易排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title function_">shellsort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">    <span class="type">int</span> h=arr.length;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">        h=h/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(h==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=h;i&lt; arr.length;i++)&#123;<span class="comment">//插入排序</span></span><br><span class="line">            <span class="type">int</span> j=i;</span><br><span class="line">            <span class="type">int</span> m=arr[j];</span><br><span class="line">            <span class="keyword">while</span> (j-h&gt;=<span class="number">0</span>&amp;&amp;arr[j-h]&gt;m)&#123;<span class="comment">//注意这里的坐标转换，根据步长找到了上一个分组位置。</span></span><br><span class="line">                arr[j]=arr[j-h];</span><br><span class="line">                j-=h;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j]=m;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>核心思想：使用基准将数据进行分组，当极限状态只剩下两个数字时，也就是完成了排序。</p><p>他和希尔排序不同的地方在于，他的分组的依据是基准，并不保证分组范围。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">    /**</span><br><span class="line">     *  @author:wenzhuo4657</span><br><span class="line">        des:  错位交换处理基准数据，最终使其变成两个区间的边界</span><br><span class="line">     */</span><br><span class="line">    public static void example(int[] arr, int left, int right) &#123;</span><br><span class="line">        if (left &gt;= right) &#123;//越界处理</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        int l = left;</span><br><span class="line">        int r = right;</span><br><span class="line"></span><br><span class="line">        int mid = arr[l];//1，作为基准，</span><br><span class="line"></span><br><span class="line">//        2,错位处理，解决了基准数据移动，即便是极端情况下，也会由于while循环条件只会到达l==r,而这个位置的交换是无效的，最后再将错位的arr[l]填充</span><br><span class="line">//        使基准数据也参与到排序中变动位置。</span><br><span class="line">        while (l &lt; r) &#123;</span><br><span class="line"></span><br><span class="line">            while (l &lt; r &amp;&amp; arr[r] &gt;= mid) &#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[l] = arr[r];</span><br><span class="line">            while (l &lt; r &amp;&amp; arr[l] &lt; mid) &#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[r] = arr[l];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[l] = mid;</span><br><span class="line"></span><br><span class="line">        example(arr, left, l-1);</span><br><span class="line"></span><br><span class="line">        example(arr, l+1, right);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>核心思想：递归找到两个数字的分组进行排序（其实按照递归是找到一个数字的分组，只是它的排序无效）</p><p>逐层向上将两个有序分组合并。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">    public static void example(int  []arr,int left,int right,int[] temp)&#123;</span><br><span class="line"></span><br><span class="line">//        该函数主要用于实现递归调用的流程</span><br><span class="line"></span><br><span class="line">        if(left&lt;right)&#123;</span><br><span class="line">            int min=(left+right)/2;</span><br><span class="line">            example(arr,left,min,temp);</span><br><span class="line">            example(arr,min+1,right,temp);</span><br><span class="line"></span><br><span class="line">            merge(arr,left,min,right,temp);//基于归并排序的递归流程，该方法所得到的数组均是局部有序，极限情况，为两个元素的区间，例如 [0,1]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *  @author:wenzhuo4657</span><br><span class="line">        des: 该排序生效的数组必须是局部有序的数组，或者说，[left,min]升序，[min+1,right]升序</span><br><span class="line">    */</span><br><span class="line">    private static void merge(int[] arr, int left, int min, int right, int[] temp) &#123;</span><br><span class="line">        int i=left;</span><br><span class="line">        int j=min+1;</span><br><span class="line">        int t=0;</span><br><span class="line">//        1,两个有序区间[left,min] [min+1,right]</span><br><span class="line">        while (i&lt;=min&amp;&amp;j&lt;=right)&#123;</span><br><span class="line">            if (arr[i]&lt;=arr[j])&#123;</span><br><span class="line">                temp[t]=arr[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                temp[t]=arr[j];</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            t++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//       2, 基于上述while循环特点，最终只剩下一边数据没有填充，并且由于区间局部有序可知，此时省下的数据可以直接顺序填充</span><br><span class="line">        while (i&lt;=min)&#123;</span><br><span class="line">            temp[t]=arr[i];</span><br><span class="line">            i++;</span><br><span class="line">            t++;</span><br><span class="line">        &#125;</span><br><span class="line">        while (j&lt;=right)&#123;</span><br><span class="line">            temp[t]=arr[j];</span><br><span class="line">            j++;</span><br><span class="line">            t++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">//        3,填充完毕，将结果复制到原本数组的区间</span><br><span class="line">        t=0;</span><br><span class="line">        for(int h=left;h&lt;=right;h++)&#123;</span><br><span class="line">            arr[h]=temp[t];</span><br><span class="line">            t++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p>按照数字位数进行一次排序。</p><p>待补充</p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>利用顺序二叉树将树结构扁平化处理，实现随机存取，并且使用大顶堆或小顶堆结构获取某个范围内的最大值或者最小值。</p><p>值得注意的是该算法对于如何将一个树调整为堆结构的方式：假设某个树除了根节点，其余节点均符合这个条件，如何为这个根节点找到合适位置进行交换？这样做了之后他也一定能够变成大顶堆或者小顶堆结构。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  @author:wenzhuo4657</span><br><span class="line">    des:  要将root下沉到合适的地方，且需要注意，以root为跟节点的这个子树（可能是0，就是这棵树本身），除了根节点以外，都符合大顶堆定义。</span><br><span class="line">         arr:顺序二叉树，</span><br><span class="line">         root: 某个节点，这里将其视为数组在该子树中找到合适位置的节点</span><br><span class="line">         length;排序范围</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">public  static  void heap1(int arr[] ,int root,int length)&#123;</span><br><span class="line">    int temp=arr[root];//临时存储根节点</span><br><span class="line"></span><br><span class="line">    for (int k=root*2+1;k&lt;length;k=k*2+1)&#123;</span><br><span class="line">        if (k+1&lt;length&amp;&amp;arr[k]&lt;arr[k+1])&#123;//1,找到左右较大的那个</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        if (temp&lt;arr[k])&#123;//判断三元组 节点root和节点root的左右节点的最大值</span><br><span class="line">            arr[root]=arr[k];//这一步相当于是移位交换，交换目标为，root和k</span><br><span class="line">            root=k;//不断更新root节点，</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[root]=temp;//完成下沉</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    public static void heap2(int []arr)&#123;</span><br><span class="line">        int temp=0;</span><br><span class="line">//转换顺序二叉树为大顶堆，arr.length/2-1==（(arr.length-1)末尾节点-1）/2 ，从最底层开始逐渐完成大顶堆定义，换言之，他的每一个子树都符合大顶堆。</span><br><span class="line">        for (int i=arr.length/2-1;i&gt;=0;i--)&#123;</span><br><span class="line">            heap1(arr,i, arr.length);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        //堆排序</span><br><span class="line">        for (int j= arr.length-1;j&gt;0;j--)&#123;</span><br><span class="line">            temp=arr[j];</span><br><span class="line">            arr[j]=arr[0];</span><br><span class="line">            arr[0]=temp;</span><br><span class="line">            heap1(arr,0, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如图的关键方法为heap1,再传入一个未知结构的树时，他通过从最后一个非叶子节点开始逐层将子树变为堆结构（通过heap1方法），最终使整个树称为堆结构。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本篇blog的语言为java实现，介意请划走&lt;/p&gt;
&lt;h1 id=&quot;八大排序算法&quot;&gt;&lt;a href=&quot;#八大排序算法&quot; class=&quot;headerlink&quot; title=&quot;八大排序算法&quot;&gt;&lt;/a&gt;八大排序算法&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;冒泡排序&lt;/li&gt;
&lt;li&gt;选择排序</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://wenzhuo4657.org/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>git入门系列（一）</title>
    <link href="http://wenzhuo4657.org/2025/03/12/git%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://wenzhuo4657.org/2025/03/12/git%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2025-03-12T07:37:15.000Z</published>
    <updated>2025-04-06T06:23:27.297Z</updated>
    
    <content type="html"><![CDATA[<h1 id="git是什么？"><a href="#git是什么？" class="headerlink" title="git是什么？"></a>git是什么？</h1><h2 id="以键值数据库为基础的文件版本控制系统"><a href="#以键值数据库为基础的文件版本控制系统" class="headerlink" title="以键值数据库为基础的文件版本控制系统"></a>以键值数据库为基础的文件版本控制系统</h2><p>参考：<a href="https://git-scm.com/book/zh/v2/%e8%b5%b7%e6%ad%a5-Git-%e6%98%af%e4%bb%80%e4%b9%88%ef%bc%9f">https://git-scm.com/book/zh/v2/%e8%b5%b7%e6%ad%a5-Git-%e6%98%af%e4%bb%80%e4%b9%88%ef%bc%9f</a></p><p>提醒： 本篇大部分在git官网都存在，只是顺序不一致，按我理解，这样有助于直接理解git的钩子机制。</p><p>传统的文件版本数据库通过累计文件差异来区分文件版本，而git则是通过不断累计文件快照，然后使用链接管理当前版本应该显示的文件！</p><ul><li>好处：如果存储文件差异，则不可避免的需要从文件内部开始操作，所带来的是复杂且绝不能出错的高安全性要求，而git管理文件链接，换言之，他只需要保存每个版本的文件链接列表即可，对于真实的文件数据，他们互相隔离。</li><li>坏处：文件系统容易变得臃肿庞大。</li></ul><p>参考:<a href="https://git-scm.com/book/zh/v2/Git-%e5%86%85%e9%83%a8%e5%8e%9f%e7%90%86-Git-%e5%af%b9%e8%b1%a1">https://git-scm.com/book/zh/v2/Git-%e5%86%85%e9%83%a8%e5%8e%9f%e7%90%86-Git-%e5%af%b9%e8%b1%a1</a></p><p>文件快照存储的方式则是键值数据库，位于.git&#x2F;objects 目录。</p><p>存储值，并返回唯一键（SHA-1 哈希值）：<code>echo &#39;test content&#39; | git hash-object -w --stdin</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo &#x27;test content&#x27; | git hash-object -w --stdin</span><br><span class="line">d670460b4b4aece5915caf5c68d12f560a9fe3e4</span><br></pre></td></tr></table></figure><p>取出： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4</span><br><span class="line">test content</span><br></pre></td></tr></table></figure><p>此外还有树对象用于组织这些键值。</p><p><img src="https://blog.wenzhuo4657.org/img/image-20250312155433934.png" alt="image-20250312155433934"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p><p>但是这仍然不是我们所熟知的git commit提交对象，这并没有提交信息的对应，这一点简单的说即是sha-1哈希值和文本的对应。随意找一个仓库都可以看到他们之间的关联。</p><p><img src="https://blog.wenzhuo4657.org/img/image-20250312155805995.png" alt="image-20250312155805995"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p><h2 id="待补充"><a href="#待补充" class="headerlink" title="待补充"></a>待补充</h2><h1 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h1><p>git的钩子位于<code>.git\hooks</code>,默认情况下都是.sample结尾，去掉这个后缀即可启用。</p><p><img src="https://blog.wenzhuo4657.org/img/image-20250312160203955.png" alt="image-20250312160203955"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p><p>尝试打开即可他先，他们都是统一的shell脚本，所以如果想要看懂是需要一点基础的。</p><p>统一机制：当以非零退出脚本时，停止提交。</p><p>提醒：shell脚本的运行并不是git管理的一部分，他们只是使用了git命令的一段编码，通常使用&#x2F;bin&#x2F;bash解释器运行。</p><h2 id="pre-commit：提交前执行"><a href="#pre-commit：提交前执行" class="headerlink" title="pre-commit：提交前执行"></a>pre-commit：提交前执行</h2><p>作用：当前分支是否存在，如果不存在会提供一个sha-1哈希值。</p><p>git rev-parse –verify HEAD  （该命令可以验证参数是否可以转换为sha-1哈希值，即他是否在对象数据库中有对应关系，常见有分支名、标签名）</p><h2 id="prepare-commit-msg：提交前执行"><a href="#prepare-commit-msg：提交前执行" class="headerlink" title="prepare-commit-msg：提交前执行"></a>prepare-commit-msg：提交前执行</h2><p>作用：</p><p>1，修改默认提交消息</p><p>2，添加gpt签名</p><p>3，将 git diff 结果插入提交消息的注释部分（咱不理解，自行查询）</p><p>修改默认消息最直接的途径就是在文件末尾<code>echo &quot;default msg&quot; &gt; $1</code>,这样就会覆盖</p><p><code>/usr/bin/perl -i.bak -ne &#39;print unless(m/^. Please enter the commit message/..m/^#$/)&#39; &quot;$COMMIT_MSG_FILE&quot;</code></p><h1 id="推荐文档"><a href="#推荐文档" class="headerlink" title="推荐文档"></a>推荐文档</h1><p><a href="https://cloud.tencent.com/developer/doc/1096">腾讯云</a></p><p><a href="https://git-scm.com/book/en/v2">git</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;git是什么？&quot;&gt;&lt;a href=&quot;#git是什么？&quot; class=&quot;headerlink&quot; title=&quot;git是什么？&quot;&gt;&lt;/a&gt;git是什么？&lt;/h1&gt;&lt;h2 id=&quot;以键值数据库为基础的文件版本控制系统&quot;&gt;&lt;a href=&quot;#以键值数据库为基础的文件版本控</summary>
      
    
    
    
    <category term="教程" scheme="http://wenzhuo4657.org/categories/%E6%95%99%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>tomcat源码阅读（二）</title>
    <link href="http://wenzhuo4657.org/2025/03/10/tomcat%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://wenzhuo4657.org/2025/03/10/tomcat%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2025-03-10T06:59:35.000Z</published>
    <updated>2025-04-06T06:23:27.297Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tomcat源码阅读"><a href="#tomcat源码阅读" class="headerlink" title="tomcat源码阅读"></a>tomcat源码阅读</h1><h2 id="日志模块梳理"><a href="#日志模块梳理" class="headerlink" title="日志模块梳理"></a>日志模块梳理</h2><p>现在日志通常分为日志门面和日志的具体实现。</p><p>日志门面：充当应用程序和日志框架之间的沟通媒介，可以在程序无感的条件下更换日志框架。</p><p>日志的具体实现：直接记录日志(console、file)，并且需要注意的是，这些信息都是由日志门面交给日志实现的。</p><p>对于非日志编程的程序员来说，我们只需要明白如何根据日志门面切换日志实现即可，没必要阅读日志实现的代码。</p><p>常见的日志门面：JCL、slf4j</p><p>常见的日志实现：JUL（java.util.logging）、log4j、logback、log4j2</p><h3 id="tomcat的日志门面JULI"><a href="#tomcat的日志门面JULI" class="headerlink" title="tomcat的日志门面JULI"></a>tomcat的日志门面JULI</h3><p>该日志门面位于源码包<code>org.apache.juli</code>,基于JCL实现的。</p><p>较为重要的三个类：</p><p>org.apache.juli.logging.Log： 日志接口</p><p>org.apache.juli.logging.DirectJDKLog：tomcat的默认日志实现。</p><p>org.apache.juli.logging.LogFactory: 与tomcat进行交互获取log接口实现。</p><p>在源码中可以看到，无论是什么类要记录日志都必须使用到Log的实现类，而对于tomcat源码来说，唯一获取该实例的途径就是LogFactory#getLog(Class&lt;?&gt; clazz)。</p><p>并且在LogFactory#release(ClassLoader classLoader)也可以看到日志实现默认为JUL,硬编码控制的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void release(ClassLoader classLoader) &#123;</span><br><span class="line">    // JULI&#x27;s log manager looks at the current classLoader so there is no</span><br><span class="line">    // need to use the passed in classLoader, the default implementation</span><br><span class="line">    // does not so calling reset in that case will break things</span><br><span class="line">    if (!LogManager.getLogManager().getClass().getName().equals(</span><br><span class="line">            &quot;java.util.logging.LogManager&quot;)) &#123;</span><br><span class="line">        LogManager.getLogManager().reset();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关于日志实现log的加载"><a href="#关于日志实现log的加载" class="headerlink" title="关于日志实现log的加载"></a>关于日志实现log的加载</h2><p>在LogFactory的无参构造器器中看到关键语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ServiceLoader&lt;Log&gt; logLoader = ServiceLoader.load(Log.class);</span><br><span class="line">Constructor&lt;? extends Log&gt; m=null;</span><br><span class="line">for (Log log: logLoader) &#123;</span><br><span class="line">    Class&lt;? extends Log&gt; c=log.getClass();</span><br><span class="line">    try &#123;</span><br><span class="line">        m=c.getConstructor(String.class);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (NoSuchMethodException | SecurityException e) &#123;</span><br><span class="line">        throw new Error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">discoveredLogConstructor=m;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中ServiceLoader.load(Log.class)是用javaspi加载META-INF&#x2F;services&#x2F;类权全限定名称实例的方法，所以如果查看常见日志框架实现的源码的话，应该是有对应文件的。</p><p>但是需要注意的是tomcat的默认实现DirectJDKLog并不在这里加载，即便我们自主添加了资源类也会报错，这是因为DirectJDKLog只有一个String参数的构造器，而ServiceLoader在遍历服务时会默认使用无参构造器。</p><p>那么DirectJDKLog是如何使用的呢？追溯iscoveredLogConstructor调用找到</p><p><code>LogFactory#getInstance(String name);</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public Log getInstance(String name) throws LogConfigurationException &#123;</span><br><span class="line">    if (discoveredLogConstructor == null) &#123;</span><br><span class="line">        return DirectJDKLog.getInstance(name); //默认实现、</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        return discoveredLogConstructor.newInstance(name);</span><br><span class="line">    &#125; catch (ReflectiveOperationException | IllegalArgumentException e) &#123;</span><br><span class="line">        throw new LogConfigurationException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="日志格式化"><a href="#日志格式化" class="headerlink" title="日志格式化"></a>日志格式化</h2><p>格式化大致就是一些日志的信息读取格式和输出格式，这一部分一定会在经过程序编码，所以直接调试即可。</p><p>例如： </p><p>StringManager:大部分都会通过这个类格式化字符串，其余可以自行查看日志门面的实现。</p><h2 id="关于文件转码"><a href="#关于文件转码" class="headerlink" title="关于文件转码"></a>关于文件转码</h2><p>java读取配置文件默认iso8859-1编码格式，如果我们已经读取了这个格式代码，那么该如何转变为UTF-8呢？</p><p>理论上来说如果有iso8859-1编码的字节，直接进行转码即可，但是我们可能会对一个字符串进行多次转码，可能导致字符串的编码不再是iso8859-1。</p><p>例如tomcat会在中途对字符串进行转码，所以到达StringManager时字符串编码已经变为了“UTF-8”，所以直接进行转码会失败</p><p><code>str= new String(str.getBytes(), StandardCharsets.*UTF_8*);</code> 失败，追溯str.getBytes()发现底层编码已经改变。这时我们可以强行指定编码。</p><p><code>str= new String(str.getBytes(StandardCharsets.ISO_8859_1), StandardCharsets.UTF_8);</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;tomcat源码阅读&quot;&gt;&lt;a href=&quot;#tomcat源码阅读&quot; class=&quot;headerlink&quot; title=&quot;tomcat源码阅读&quot;&gt;&lt;/a&gt;tomcat源码阅读&lt;/h1&gt;&lt;h2 id=&quot;日志模块梳理&quot;&gt;&lt;a href=&quot;#日志模块梳理&quot; class=&quot;</summary>
      
    
    
    
    <category term="源码" scheme="http://wenzhuo4657.org/categories/%E6%BA%90%E7%A0%81/"/>
    
    
  </entry>
  
  <entry>
    <title>tomcat源码阅读（一）</title>
    <link href="http://wenzhuo4657.org/2025/03/07/tomcat%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://wenzhuo4657.org/2025/03/07/tomcat%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2025-03-07T08:07:46.000Z</published>
    <updated>2025-04-06T06:23:27.297Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tomcat源码"><a href="#tomcat源码" class="headerlink" title="tomcat源码"></a>tomcat源码</h1><h2 id="idea环境搭建"><a href="#idea环境搭建" class="headerlink" title="idea环境搭建"></a>idea环境搭建</h2><p>源码版本apache-tomcat-9.0.43-src</p><p><a href="https://archive.apache.org/dist/tomcat/tomcat-9/v9.0.43/src/">https://archive.apache.org/dist/tomcat/tomcat-9/v9.0.43/src/</a></p><p>注意： 不同版本的搭建方式可能略有不同，但这源码核心是大差不差的。</p><h3 id="安装ant-已安装的可以直接跳过"><a href="#安装ant-已安装的可以直接跳过" class="headerlink" title="安装ant(已安装的可以直接跳过)"></a>安装ant(已安装的可以直接跳过)</h3><p>Apache Ant 是一个帮助构建软件的 Java 库和命令行工具。</p><p>官网：<a href="https://ant.apache.org/bindownload.cgi">https://ant.apache.org/bindownload.cgi</a></p><p>直接下载最新版即可，解压之后设置环境变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ANT_HOME=/Library/Apache/apache-ant-1.9.15</span><br><span class="line">PATH=$PATH:$ANT_HOME/bin</span><br></pre></td></tr></table></figure><p>使用<code>ant -verison</code>验证安装是否成功</p><p><img src="https://blog.wenzhuo4657.org/img/image-20250307171403529.png" alt="image-20250307171403529"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p><h3 id="构建项目"><a href="#构建项目" class="headerlink" title="构建项目"></a>构建项目</h3><p><em>在打开idea之前操作，这一点非常重要！！！否则会由于编译器的一些操作导致XXXXX</em></p><p>直接将res目录idea-support中的.idea文件粘贴到根目录中的.idea（手动创建</p><p><img src="https://blog.wenzhuo4657.org/img/image-20250309134412453.png" alt="image-20250309134412453"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p><p><img src="https://blog.wenzhuo4657.org/img/image-20250309134454556.png" alt="image-20250309134454556"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p><p><img src="https://blog.wenzhuo4657.org/img/image-20250309134544101.png" alt="image-20250309134544101"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p><p>此时打开项目可以发现项目被正确加载，但是会依赖报错</p><p><img src="https://blog.wenzhuo4657.org/img/image-20250309135659189.png" alt="image-20250309135659189"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p><p>尝试构建项目，启动test</p><p><img src="https://blog.wenzhuo4657.org/img/image-20250309135743059.png" alt="image-20250309135743059"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p><p><img src="https://blog.wenzhuo4657.org/img/image-20250309134654470.png" alt="image-20250309134654470"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p><p>将这些jar包和ant目录下的lib库加入项目的外部库即可。</p><p><img src="https://blog.wenzhuo4657.org/img/image-20250309141125493.png" alt="image-20250309141125493"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>找到启动类Bootstrap</p><p><img src="https://blog.wenzhuo4657.org/img/image-20250309141245515.png" alt="image-20250309141245515"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p><p><img src="https://blog.wenzhuo4657.org/img/image-20250309141253099.png" alt="image-20250309141253099"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p><h1 id="中文乱码"><a href="#中文乱码" class="headerlink" title="中文乱码"></a>中文乱码</h1><p>对于乱码，网上搜索在日志配置中更改编码，</p><p><a href="https://blog.csdn.net/weixin_44109450/article/details/126544310">https://blog.csdn.net/weixin_44109450/article/details/126544310</a></p><p>但是对于源码编译环境来说，似乎并不会读取conf下的配置，追溯源码找到<code>java.util.logging.ConsoleHandler</code>.</p><p>断点调试发现，并没有获取到配置</p><p><img src="https://blog.wenzhuo4657.org/img/image-20250309142742777.png" alt="image-20250309142742777"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p><p>并且由于该类属于依赖包jdk的一部分，<img src="https://blog.wenzhuo4657.org/img/image-20250309142835530.png" alt="image-20250309142835530"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p><p>进一步追溯之后发现关键读取文件的方法LogManager#readConfiguration（）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String fname = System.getProperty(&quot;java.util.logging.config.file&quot;);</span><br><span class="line">     if (fname == null) &#123;</span><br><span class="line">         fname = System.getProperty(&quot;java.home&quot;);</span><br><span class="line">         if (fname == null) &#123;</span><br><span class="line">             throw new Error(&quot;Can&#x27;t find java.home ??&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">         File f = new File(fname, &quot;lib&quot;);</span><br><span class="line">         f = new File(f, &quot;logging.properties&quot;);</span><br><span class="line">         fname = f.getCanonicalPath();</span><br><span class="line">     &#125;</span><br><span class="line">     try (final InputStream in = new FileInputStream(fname)) &#123;</span><br><span class="line">         final BufferedInputStream bin = new BufferedInputStream(in);</span><br><span class="line">         readConfiguration(bin);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>首先说结论，无论使更改成conf还是jdk目录下的logging.properties,他们所影响的编码都只是外层的一部分，不能影响tomcat输出的报错信息。</p><p>但是我注意到了另外一个属性java.util.logging.ConsoleHandler.formatter，该属性用于格式化输出的文本，但是默认的使jdk的jar包实现，所以我转到tomcat的配置文件中寻找实现，尝试修改启动后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.util.logging.ConsoleHandler.level = INFO</span><br><span class="line"># java.util.logging.ConsoleHandler.formatter = java.util.logging.SimpleFormatter</span><br><span class="line">java.util.logging.ConsoleHandler.formatter = org.apache.juli.OneLineFormatter</span><br><span class="line">java.util.logging.ConsoleHandler.encoding= UTF-8</span><br></pre></td></tr></table></figure><p>修改后无效，放弃处理，在SimpleFormatter#format后追溯输出语句，最终追溯的源码包下的适配类<code>org.apache.juli.logging.DirectJDKLog#log</code>,查看输出类后发现他们都使用<code>StringManager.getString(final String key, final Object... args) </code>格式化。</p><p>最终追踪到资源包类<code>PropertyResourceBundle</code>,发现资源读取的全是乱码，而编码格式均是正确的。</p><p>追溯读取资源的源码后找到关键方法</p><p><code>bundle = *findBundle*(cacheKey, candidateLocales, formats, 0, control, baseBundle);</code></p><p>查看输出乱码的类，去寻找StringManager的绑定资源可发现</p><p>对应资源名称为<code>org.apache.catalina.startup.LocalStrings zh_CN </code></p><p><img src="https://blog.wenzhuo4657.org/img/image-20250309170614673.png" alt="image-20250309170614673"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p><p><img src="https://blog.wenzhuo4657.org/img/image-20250309170334320.png" alt="image-20250309170334320"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p><a href="https://blog.csdn.net/weixin_54430656/article/details/122440049">https://blog.csdn.net/weixin_54430656/article/details/122440049</a></p><p>最终解决实际上是我的一个误区，在前面的编码转换时我总是将错误的编码转换为utf-8,而忽略了java读取默认时<code>iso8859-1</code>的编码读取才导致的中文乱码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (bundle != null) &#123;</span><br><span class="line">          str = bundle.getString(key);</span><br><span class="line">          str= new String(str.getBytes(StandardCharsets.ISO_8859_1), StandardCharsets.UTF_8);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br></pre></td></tr></table></figure><p><img src="https://blog.wenzhuo4657.org/img/image-20250309172916003.png" alt="image-20250309172916003"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;tomcat源码&quot;&gt;&lt;a href=&quot;#tomcat源码&quot; class=&quot;headerlink&quot; title=&quot;tomcat源码&quot;&gt;&lt;/a&gt;tomcat源码&lt;/h1&gt;&lt;h2 id=&quot;idea环境搭建&quot;&gt;&lt;a href=&quot;#idea环境搭建&quot; class=&quot;head</summary>
      
    
    
    
    <category term="源码" scheme="http://wenzhuo4657.org/categories/%E6%BA%90%E7%A0%81/"/>
    
    
  </entry>
  
  <entry>
    <title>零拷贝</title>
    <link href="http://wenzhuo4657.org/2025/02/15/%E9%9B%B6%E6%8B%B7%E8%B4%9D/"/>
    <id>http://wenzhuo4657.org/2025/02/15/%E9%9B%B6%E6%8B%B7%E8%B4%9D/</id>
    <published>2025-02-15T08:23:43.000Z</published>
    <updated>2025-04-06T06:23:27.297Z</updated>
    
    <content type="html"><![CDATA[<p>首先说结论，零拷贝技术是针对与磁盘中数据到网卡发送数据的一个简化，是系统函数级别的优化，与程序编程无关，在使用中我们只需要调用即可。</p><h2 id="系统拷贝-read-write"><a href="#系统拷贝-read-write" class="headerlink" title="系统拷贝 read&#x2F;write"></a>系统拷贝 read&#x2F;write</h2><p>前置概念：</p><ul><li>页缓存（内核缓冲区）：该区域是为了提升磁盘数据的读写速度所设立的一个区域，处于（主存）内存当中。</li><li>socket缓冲区：是内核为每个 Socket 分配的内存区域，用于临时存储发送和接收的数据，处于（主存）内存当中。</li></ul><p>os系统的加载，学过操作系统的都知道，内存当中的区域分为内核态和用户态。</p><p>在操作系统启动时，cpu会根据cs:ip表示的地址进行寻址，找到位于磁盘当中的操作系统程序部分，最终结果可以认为将系统代码搬进了ram主存当中，并且设置了一些列安全手段，除此之外则还为用户态提供了一系列系统函数。</p><p><strong>磁盘&#x3D;&#x3D; “外设”</strong>：</p><p>对于cpu来说，磁盘相当于外设，它会通过外设上的寄存器来管理，此处衍生出的技术为dma。</p><ul><li>dma:为了避免cpu的重复性的移动地址等的操作，进行的一项优化，具体来说，读取数据到缓冲区等重复性劳动可以交给dma设备。</li></ul><p>但是dma拷贝也并非万能，在某些场景下它不能使用</p><ul><li>用户空间和内核空间之间的数据拷贝：内核不能直接访问用户态内存</li><li>调试和诊断：dma是硬件自动完成，难以插入调试逻辑。</li></ul><p><img src="http://blog.wenzhuo4657.org/img/image-20250215171022865.png" alt="image-20250215171022865"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p><h1 id="系统函数"><a href="#系统函数" class="headerlink" title="系统函数"></a>系统函数</h1><h2 id="mmap-write"><a href="#mmap-write" class="headerlink" title="mmap+write"></a>mmap+write</h2><p>将page buffer和程序工作缓存空间进行映射，减少page-buffer-&gt;程序缓存的cpu拷贝，但是对于程序工作缓存-》socket buffer这一部分仍然需要cpu拷贝。</p><p><strong>为什么仍然是cpu拷贝？</strong></p><p>这里将其理解为，我们仅仅是做到了在用户态可以看到page buffer,但是并没有打破用户态和内核态的内存空间限制，所以此处的拷贝仍然是cpu拷贝，而并非dma拷贝。</p><p><img src="https://blog.wenzhuo4657.org/img/image-20250215172019525.png" alt="image-20250215172019525"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p><h2 id="sendfile"><a href="#sendfile" class="headerlink" title="sendfile"></a>sendfile</h2><p><img src="https://blog.wenzhuo4657.org/img/image-20250215172632051.png" alt="image-20250215172632051"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p><p>如图，sendfile使page buff直接拷贝到socket buffer。</p><p><strong>为什么使用的使cpu拷贝，而非DMA拷贝？</strong></p><p>ds给我的答案使，DMA通常用于外设和主存之间，</p><h2 id="网卡支持SG-DMA技术的sendfile"><a href="#网卡支持SG-DMA技术的sendfile" class="headerlink" title="网卡支持SG-DMA技术的sendfile"></a>网卡支持SG-DMA技术的sendfile</h2><p><img src="https://blog.wenzhuo4657.org/img/image-20250215173227238.png" alt="image-20250215173227238"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p><p>如图，该函数实际上是外设功能的调用，原本socket buffer的功能被网卡认为多余，获取可以被替代之类的，提出直接从page buffer中拷贝。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>实际应用：</p><p>普通的文件读写：read&#x2F;write,有利于提高系统速度，但这是非具体场景的随机读取。</p><p>rocketmq: mmap+write，适合小文件并行，因为该区域用户缓存都可以看到。</p><p>kafka:sendfile,适合大文件，或者说对于小文件并行支持不好，因为为了安全性，通常会对page buffer进行锁定，避免并发问题。</p><p>ps:上述总结可以喂给ds，会得到更加优质的回答！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;首先说结论，零拷贝技术是针对与磁盘中数据到网卡发送数据的一个简化，是系统函数级别的优化，与程序编程无关，在使用中我们只需要调用即可。&lt;/p&gt;
&lt;h2 id=&quot;系统拷贝-read-write&quot;&gt;&lt;a href=&quot;#系统拷贝-read-write&quot; class=&quot;headerl</summary>
      
    
    
    
    <category term="OS" scheme="http://wenzhuo4657.org/categories/OS/"/>
    
    
  </entry>
  
  <entry>
    <title>dubbo的spi</title>
    <link href="http://wenzhuo4657.org/2025/01/22/dubbo%E7%9A%84spi/"/>
    <id>http://wenzhuo4657.org/2025/01/22/dubbo%E7%9A%84spi/</id>
    <published>2025-01-22T08:47:11.000Z</published>
    <updated>2025-04-06T06:23:27.297Z</updated>
    
    <content type="html"><![CDATA[<p>dubbo的spi相比于jdk的spi而言，提供了更为强大的功能，主要来说是帮助我们更好的面对多个服务互相依赖的场景，并且做了一定优化。（例如：按需加载）</p><h2 id="按需加载"><a href="#按需加载" class="headerlink" title="按需加载"></a>按需加载</h2><p>jdk的spi的配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.example.ToyotaCar</span><br><span class="line">org.example.HondaCar</span><br></pre></td></tr></table></figure><p>dubbo的spi的配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">toyota=org.example.ToyotaCar</span><br><span class="line">honda=org.example.HondaCar</span><br><span class="line">wrapper=org.example.aop.CarWrapper1</span><br><span class="line">wrapper=org.example.aop.CarWrapper2</span><br><span class="line">Race=org.example.ioc.RaceRes</span><br><span class="line">red=org.example.ioc.PenRes</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>二者的区别在于dubbo中使用键值，可以实现按需加载，请注意，该加载并非指配置文件的加载，而加载配置文件之后的对于<strong>服务对象的实例化</strong>。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="jdk的spi"><a href="#jdk的spi" class="headerlink" title="jdk的spi"></a>jdk的spi</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">      ServiceLoader&lt;Car&gt; load = ServiceLoader.load(Car.class);</span><br><span class="line"></span><br><span class="line">//        获取迭代器遍历</span><br><span class="line">        Iterator&lt;Car&gt; iterator = load.iterator();</span><br><span class="line">        while (iterator.hasNext())&#123;</span><br><span class="line">            Car registry = iterator.next();</span><br><span class="line">            registry.run();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br></pre></td></tr></table></figure><p>追溯源码可以看到迭代器内部。</p><p><img src="https://blog.wenzhuo4657.org/img/image-20250122174648892.png" alt="image-20250122174648892"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p><p>关键成员变量</p><p>Iterator<String> pending ;&#x2F;&#x2F;配置文件读取的数据  <strong>该变量也是迭代器</strong><br>String nextName ;&#x2F;&#x2F;下一个将要读取的配置</p><p>存在关键方法</p><p>hasNextService：用于判断下一个服务名称，即配置文件当中的全限定类名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private boolean hasNextService() &#123;</span><br><span class="line">     if (nextName != null) &#123;</span><br><span class="line">         return true;</span><br><span class="line">     &#125;</span><br><span class="line">     if (configs == null) &#123;</span><br><span class="line">         try &#123;</span><br><span class="line">             String fullName = PREFIX + service.getName();</span><br><span class="line">             if (loader == null)</span><br><span class="line">                 configs = ClassLoader.getSystemResources(fullName);</span><br><span class="line">             else</span><br><span class="line">                 configs = loader.getResources(fullName);</span><br><span class="line">         &#125; catch (IOException x) &#123;</span><br><span class="line">             fail(service, &quot;Error locating configuration files&quot;, x);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     while ((pending == null) || !pending.hasNext()) &#123;</span><br><span class="line">         if (!configs.hasMoreElements()) &#123;</span><br><span class="line">             return false;</span><br><span class="line">         &#125;</span><br><span class="line">         pending = parse(service, configs.nextElement());</span><br><span class="line">     &#125;</span><br><span class="line">     nextName = pending.next();//获取下一个元素，</span><br><span class="line">     return true;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>nextService：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private S nextService() &#123;</span><br><span class="line">        if (!hasNextService())</span><br><span class="line">            throw new NoSuchElementException();</span><br><span class="line">        String cn = nextName;</span><br><span class="line">        nextName = null;</span><br><span class="line">        Class&lt;?&gt; c = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            c = Class.forName(cn, false, loader);//获取类加载器</span><br><span class="line">        &#125; catch (ClassNotFoundException x) &#123;</span><br><span class="line">            fail(service,</span><br><span class="line">                 &quot;Provider &quot; + cn + &quot; not found&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (!service.isAssignableFrom(c)) &#123;</span><br><span class="line">            fail(service,</span><br><span class="line">                 &quot;Provider &quot; + cn  + &quot; not a subtype&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            S p = service.cast(c.newInstance());//实例化对象</span><br><span class="line">            providers.put(cn, p);//延迟加载，将其收入到一个map集合当中</span><br><span class="line">            return p;//返回加载元素</span><br><span class="line">        &#125; catch (Throwable x) &#123;</span><br><span class="line">            fail(service,</span><br><span class="line">                 &quot;Provider &quot; + cn + &quot; could not be instantiated&quot;,</span><br><span class="line">                 x);</span><br><span class="line">        &#125;</span><br><span class="line">        throw new Error();          // This cannot happen</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="dubbo的spi"><a href="#dubbo的spi" class="headerlink" title="dubbo的spi"></a>dubbo的spi</h4><p>dubbo的spi则使用键值加载。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ExtensionLoader&lt;Car&gt; extensionLoader;</span><br><span class="line">@Before</span><br><span class="line">public void  fi()&#123;</span><br><span class="line">    extensionLoader = ExtensionLoader.getExtensionLoader(Car.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  @author:wenzhuo4657</span><br><span class="line">    des:</span><br><span class="line">dubbo基本服务发现，和jdk的主要区别在于可以用键去获取指定的扩展实现。</span><br><span class="line">*/</span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        Car car = extensionLoader.getExtension(&quot;ali&quot;,false);//false表示不进行自动装配等其他配置，默认为true,</span><br><span class="line">        car.run();</span><br><span class="line">        if (car instanceof HondaCar)&#123;</span><br><span class="line">            System.out.println(&quot;true&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure><p>追溯getExtension方法，可以看到关键实例化对象的createExtension方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">private T createExtension(String name, boolean wrap) &#123;</span><br><span class="line">       Class&lt;?&gt; clazz = getExtensionClasses().get(name);</span><br><span class="line">       if (clazz == null) &#123;</span><br><span class="line">           throw findException(name);</span><br><span class="line">       &#125;</span><br><span class="line">       try &#123;</span><br><span class="line">           T instance = (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class="line">           if (instance == null) &#123;</span><br><span class="line">               EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance());</span><br><span class="line">               instance = (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class="line">           &#125;</span><br><span class="line">           injectExtension(instance);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           if (wrap) &#123;</span><br><span class="line"></span><br><span class="line">               List&lt;Class&lt;?&gt;&gt; wrapperClassesList = new ArrayList&lt;&gt;();</span><br><span class="line">               if (cachedWrapperClasses != null) &#123;</span><br><span class="line">                   wrapperClassesList.addAll(cachedWrapperClasses);</span><br><span class="line">                   wrapperClassesList.sort(WrapperComparator.COMPARATOR);</span><br><span class="line">                   Collections.reverse(wrapperClassesList);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               if (CollectionUtils.isNotEmpty(wrapperClassesList)) &#123;</span><br><span class="line">                   for (Class&lt;?&gt; wrapperClass : wrapperClassesList) &#123;</span><br><span class="line">                       Wrapper wrapper = wrapperClass.getAnnotation(Wrapper.class);</span><br><span class="line">                       if (wrapper == null</span><br><span class="line">                               || (ArrayUtils.contains(wrapper.matches(), name) &amp;&amp; !ArrayUtils.contains(wrapper.mismatches(), name))) &#123;</span><br><span class="line">                           instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           initExtension(instance);</span><br><span class="line">           return instance;</span><br><span class="line">       &#125; catch (Throwable t) &#123;</span><br><span class="line">           throw new IllegalStateException(&quot;Extension instance (name: &quot; + name + &quot;, class: &quot; +</span><br><span class="line">                   type + &quot;) couldn&#x27;t be instantiated: &quot; + t.getMessage(), t);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>1，提前获取类加载器，</p><p>Class<?> clazz = getExtensionClasses().get(name);方法内部可以看到有一个成员变量`private final Holder<Map<String, Class<?>&gt;&gt; cachedClasses &#x3D; new Holder&lt;&gt;();&#96;</p><h1 id="DUBBO的扩展点加载"><a href="#DUBBO的扩展点加载" class="headerlink" title="DUBBO的扩展点加载"></a>DUBBO的扩展点加载</h1><p><a href="https://cn.dubbo.apache.org/zh-cn/docsv2.7/dev/spi/">扩展点加载 | Apache Dubbo</a>:该文档旨在对官网翻译，助于理解</p><p>dubbo扩展点加载与单纯的spi不同，会使用Wrapper包装类对服务方法进行扩展，实际上将，这有点像aop。</p><p>包装之后，获取的对象将不是所需要的服务对象，而是包装类对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class XxxProtocolWrapper implements Protocol &#123;</span><br><span class="line">    Protocol impl;</span><br><span class="line"> </span><br><span class="line">    public XxxProtocolWrapper(Protocol protocol) &#123; impl = protocol; &#125;</span><br><span class="line"> </span><br><span class="line">    // 接口方法做一个操作后，再调用extension的方法</span><br><span class="line">    public void refer() &#123;</span><br><span class="line">        //... 一些操作</span><br><span class="line">        impl.refer();</span><br><span class="line">        // ... 一些操作</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以在加载是通过参数指定是否开启包装类代理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Car car = extensionLoader.getExtension(&quot;ali&quot;,false);//false表示不进行自动装配等其他配置，默认为true,</span><br></pre></td></tr></table></figure><h2 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h2><p>自动装配对应spring DI自动注入，判断方式为方法名称。</p><p>形如setWheelMaker 方法的 WheelMaker 也是扩展点则会注入 WheelMaker 的实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class RaceCarMaker implements CarMaker &#123;</span><br><span class="line">    WheelMaker wheelMaker;</span><br><span class="line"> </span><br><span class="line">    public void setWheelMaker(WheelMaker wheelMaker) &#123;</span><br><span class="line">        this.wheelMaker = wheelMaker;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public Car makeCar() &#123;</span><br><span class="line">        // ...</span><br><span class="line">        Wheel wheel = wheelMaker.makeWheel();</span><br><span class="line">        // ...</span><br><span class="line">        return new RaceCar(wheel, ...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这种注入无法指定依赖服务的实现，一般为默认实现或者优先级判断使用哪个实现，但无论是哪种都是全局唯一的默认，无法实现特例。</p><h2 id="自适应装配"><a href="#自适应装配" class="headerlink" title="自适应装配"></a>自适应装配</h2><p>该装配利用了包装类和方法参数，实现在扩展时加载服务对象并调用方法。</p><p>（<strong>该方式和自动装配并不冲突，只是并不使用自动装配的服务，并且由于包装类方法执行的缘故，甚至不用判断是否使用默认服务。</strong>）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface CarMaker &#123;</span><br><span class="line"> @Adaptive(&#123;&quot;CarMaker&quot;&#125;)</span><br><span class="line">    Car makeCar(URL url);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public interface WheelMaker &#123;</span><br><span class="line"> @Adaptive(&#123;&quot;WheelMaker&quot;&#125;)</span><br><span class="line">    Wheel makeWheel(URL url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class RaceCarMaker implements CarMaker &#123;</span><br><span class="line">    WheelMaker wheelMaker;</span><br><span class="line"> </span><br><span class="line">    public void setWheelMaker(WheelMaker wheelMaker) &#123;</span><br><span class="line">        this.wheelMaker = wheelMaker;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public Car makeCar(URL url) &#123;</span><br><span class="line">        // ...</span><br><span class="line">        Wheel wheel = wheelMaker.makeWheel(url);</span><br><span class="line">        // ...</span><br><span class="line">        return new RaceCar(wheel, ...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Pen pen = extensionLoader.getAdaptiveExtension();</span><br><span class="line">URL url = new URL(&quot;dubbo&quot;, &quot;127.0.0.1&quot;, 20880).</span><br><span class="line">        addParameter(&quot;WheelMaker&quot;, &quot;wheel&quot;).</span><br><span class="line">        addParameter(&quot;CarMaker&quot;,&quot;car&quot;);</span><br><span class="line"></span><br><span class="line">// 调用方法</span><br><span class="line">pen.run(url);</span><br></pre></td></tr></table></figure><p>使用@Adaptive注解定义包装类实例化服务的key,在url参数中指定，最终实现特定服务调用特定服务。</p><p>深入源码中即可发现这一实现的依赖于包装类。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public java.lang.String queryCountry(org.apache.dubbo.common.URL arg0) &#123;         if (arg0 == null) throw new IllegalArgumentException(&quot;url == null&quot;);         org.apache.dubbo.common.URL url = arg0;         String extName = url.getParameter(&quot;person.service&quot;, &quot;china&quot;);//获取指定扩展服务         if (extName == null)             throw new IllegalStateException(&quot;Failed to get extension (org.dubbo.spi.example.PersonService) name from url (&quot; + url.toString() + &quot;) use keys([person.service])&quot;);         org.dubbo.spi.example.PersonService extension = (org.dubbo.spi.example.PersonService) ExtensionLoader.getExtensionLoader(org.dubbo.spi.example.PersonService.class).getExtension(extName); //扩展服务加载      </span><br><span class="line">return extension.queryCountry(arg0);//扩展服务执行    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它会在扩展执行时通过url参数中的指定值，加载扩展服务执行。 </p><h1 id="补充要点"><a href="#补充要点" class="headerlink" title="补充要点"></a>补充要点</h1><h2 id="jdk的加载默认使用无参构造器"><a href="#jdk的加载默认使用无参构造器" class="headerlink" title="jdk的加载默认使用无参构造器"></a>jdk的加载默认使用无参构造器</h2><p>这一点可以在ServiceLoader.LazyIterator#nextService()中看到</p><p><code>S p = service.cast(c.newInstance());</code></p><p>而Dubbo可以通过url携带参数实例化。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;dubbo的spi相比于jdk的spi而言，提供了更为强大的功能，主要来说是帮助我们更好的面对多个服务互相依赖的场景，并且做了一定优化。（例如：按需加载）&lt;/p&gt;
&lt;h2 id=&quot;按需加载&quot;&gt;&lt;a href=&quot;#按需加载&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="dubbo" scheme="http://wenzhuo4657.org/categories/dubbo/"/>
    
    
  </entry>
  
  <entry>
    <title>单路分发和多路分发</title>
    <link href="http://wenzhuo4657.org/2025/01/21/%E5%8D%95%E8%B7%AF%E5%88%86%E5%8F%91%E5%92%8C%E5%A4%9A%E8%B7%AF%E5%88%86%E5%8F%91/"/>
    <id>http://wenzhuo4657.org/2025/01/21/%E5%8D%95%E8%B7%AF%E5%88%86%E5%8F%91%E5%92%8C%E5%A4%9A%E8%B7%AF%E5%88%86%E5%8F%91/</id>
    <published>2025-01-21T07:01:05.000Z</published>
    <updated>2025-04-06T06:23:27.297Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单路分发"><a href="#单路分发" class="headerlink" title="单路分发"></a>单路分发</h1><p>前置概念：<br>接收者对象：方法调用的目标对象<br>动态链接：在Java源文件被编译到字节码文件时，所有的变量和方法引用都作为符号引用保存在<strong>class文件的常量池</strong>里。<br>引用类型&#x2F;静态类型：java对象的声明类型<br>运行类型：jvm中对象的实际类型，是堆区数据的对象类型。</p><p>java对象的多态性导致其引用类型和运行类型两者的区分，且各自的方法可能出现重写的现象，因而在对象执行过程中需要找到正确的方法。jvm只有在运行阶段才会创建对象，调用方法时根据动态链接找到堆区的方法实现。。</p><p>java单路分发：接收者对象（实际上是指堆区创建的对象，也就是运行类型）调用方法时根据动态链接找到方法区的真正实现。</p><p>单路分发定义：查找方法只能根据接收者对象判断，而不考虑方法参数的实际类型。</p><p>例如：<code>string.valueof(bi)</code> 接收者对象为string,单路分发只会考虑方法参数的引用类型，而非实际类型。</p><p>注意：我们说java方法调用是单路分发，不考虑方法参数的<strong>实际类型</strong>。其中对于实际类型的理解需要和重载相区分，因为重载是从参数的引用类型进行选择。而我们所说的单路分发、多路分发实际上是根据方法的实际运行类型进行选择方法的具体实现（动态链接），而java的机制仅仅只支持根据接受者对象来选择方法的动态链接，因此java的分发机制是单路分发。</p><ul><li>方法重载的匹配：编译器在编译时根据参数类型选择最匹配的方法。</li><li>编译器生成的字节码：编译器将方法调用转换为字节码指令，这些指令包含了方法调用的具体信息。</li><li>动态链接：在类加载时，方法引用被解析为具体的方法地址。在方法调用时，JVM 根据接收者对象的实际类型选择具体的方法实现。</li></ul><h1 id="两路分发和多路分发"><a href="#两路分发和多路分发" class="headerlink" title="两路分发和多路分发"></a>两路分发和多路分发</h1><p>参考;<a href="https://www.cnblogs.com/Yee-Q/p/14035322.html">Java 枚举 enum 详解 - 低吟不作语 - 博客园</a></p><p>java实现两路分发实际上就是在方法调用中再次触发方法调用，根据方法参数的实际类型进行选择方法。</p><p>硬编码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">## 可以使用枚举、swich简化代码实现</span><br><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> Outcome <span class="title function_">compete</span><span class="params">(Item it)</span> </span><br><span class="line">&#123; <span class="keyword">return</span> </span><br><span class="line">it.eval(<span class="built_in">this</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>且注意，只有<code>it.eveal(this)</code>找到的方法才是期望的方法，第一次执行找到compete方法是实现两路分发的过程。</p><p> EnumMap 实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> enums;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> enums.Outcome.*;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">RoShamBo5</span> <span class="keyword">implements</span> <span class="title class_">Competitor</span>&lt;RoShamBo5&gt; &#123;</span><br><span class="line">    PAPER, SCISSORS, ROCK;</span><br><span class="line">    <span class="keyword">static</span> EnumMap&lt;RoShamBo5,EnumMap&lt;RoShamBo5,Outcome&gt;&gt;</span><br><span class="line">            table = <span class="keyword">new</span> <span class="title class_">EnumMap</span>&lt;&gt;(RoShamBo5.class);</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(RoShamBo5 it : RoShamBo5.values())</span><br><span class="line">            table.put(it, <span class="keyword">new</span> <span class="title class_">EnumMap</span>&lt;&gt;(RoShamBo5.class));</span><br><span class="line">        initRow(PAPER, DRAW, LOSE, WIN);</span><br><span class="line">        initRow(SCISSORS, WIN, DRAW, LOSE);</span><br><span class="line">        initRow(ROCK, LOSE, WIN, DRAW);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">initRow</span><span class="params">(RoShamBo5 it,</span></span><br><span class="line"><span class="params">                        Outcome vPAPER, Outcome vSCISSORS, Outcome vROCK)</span> &#123;</span><br><span class="line">        EnumMap&lt;RoShamBo5,Outcome&gt; row =</span><br><span class="line">                RoShamBo5.table.get(it);</span><br><span class="line">        row.put(RoShamBo5.PAPER, vPAPER);</span><br><span class="line">        row.put(RoShamBo5.SCISSORS, vSCISSORS);</span><br><span class="line">        row.put(RoShamBo5.ROCK, vROCK);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Outcome <span class="title function_">compete</span><span class="params">(RoShamBo5 it)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> table.get(<span class="built_in">this</span>).get(it);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        RoShamBo.play(RoShamBo5.class, <span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实际上依旧是二次选择，只是没有触发方法的动态链接机制，而是通过map类型手动填充了一张表格进行分发。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;单路分发&quot;&gt;&lt;a href=&quot;#单路分发&quot; class=&quot;headerlink&quot; title=&quot;单路分发&quot;&gt;&lt;/a&gt;单路分发&lt;/h1&gt;&lt;p&gt;前置概念：&lt;br&gt;接收者对象：方法调用的目标对象&lt;br&gt;动态链接：在Java源文件被编译到字节码文件时，所有的变量和方法引用</summary>
      
    
    
    
    <category term="设计思路" scheme="http://wenzhuo4657.org/categories/%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF/"/>
    
    
  </entry>
  
</feed>
